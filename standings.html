<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="robots" content="noindex, nofollow">
<title>Standings</title>

<style>
:root{ font-size: 12.5px; --btn-angle:135deg; }
html, body{
  margin:0; padding:0;
  background:#f7f8fa; color:#222;
  font-family:"Segoe UI", Roboto, Arial, sans-serif;
  -webkit-text-size-adjust:100%;
  text-size-adjust:100%;
}
body{
  padding:12px;
  padding-bottom: calc(16px + env(safe-area-inset-bottom));
  overflow-x:hidden;
}

/* panels */
.panel{
  background:#fff;
  border-radius:18px;
  box-shadow:0 10px 30px rgba(0,0,0,.08);
  padding:14px;
  margin:12px 0;
}
.h2{ font-size:14px; font-weight:950; margin:0 0 10px; text-transform:uppercase; letter-spacing:.02em; }
.small{ font-size:11px; color:#667085; font-weight:800; }

/* table */
.table-wrap{ overflow-x:auto; -webkit-overflow-scrolling:touch; }
table{ width:100%; border-collapse:collapse; table-layout:fixed; }
thead th{
  font-size:11px;
  letter-spacing:.06em;
  color:#4b5563;
  padding:10px 10px;
  border-bottom:1px solid #eef2f7;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  text-transform:uppercase;
  text-align:center;
}
tbody td{
  padding:10px 10px;
  border-bottom:1px solid #f1f5f9;
  font-size:13px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
tbody td:first-child{ text-align:left; }
thead th:nth-child(n+2),
tbody td:nth-child(n+2){ text-align:center; }

.pill{
  display:inline-flex;
  align-items:center;
  padding:4px 9px;
  border-radius:999px;
  background:#f1f5f9;
  font-weight:900;
  color:#111827;
  font-size:11.5px;
}

/* Non-collapsible header that matches the collapsible <summary> look (RED like active pages) */
.panel-titlebar{
  display:flex;
  align-items:center;
  justify-content:center;
  margin:-14px -14px 12px;
  height:32px;
  padding:0 14px;
  box-sizing:border-box;
  text-transform:uppercase;
  font-weight:950;
  font-size:14px;
  letter-spacing:.02em;
  user-select:none;
  background: linear-gradient(var(--btn-angle), #ff3b3b, #e40000);
  color:#fff;
  border-top-left-radius:18px;
  border-top-right-radius:18px;
}

/* Collapsible panels (same feel as Stats page) */
details.collapsible{ padding:0; }
details.collapsible > summary{
  display:flex;
  align-items:center;
  justify-content:center;
  padding:12px 14px;
  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color: transparent;
  font-weight:950;
  font-size:14px;
  letter-spacing:.02em;
  text-transform:uppercase;
  position:relative;
  list-style:none;
}
details.collapsible > summary::-webkit-details-marker{ display:none; }
details.collapsible .collap-chevron{
  position:absolute;
  right:14px;
  top:50%;
  transform:translateY(-50%) rotate(0deg);
  transition: transform 180ms ease;
  font-size:18px;
  color:#667085;
}
details.collapsible[open] .collap-chevron{ transform: translateY(-50%) rotate(180deg); }
details.collapsible .collap-body{ padding:0 14px 14px; }
details.collapsible .detailsBody{ padding:0 14px 14px; }

/* =========================================================
   Match-card styling (from your Stats match cards)
   ========================================================= */
.match-card{
  background:#fff;
  border:1px solid #eef2f7;
  border-radius:16px;
  padding:8px 10px;
  display:grid;
  grid-template-columns: 1fr 86px 1fr;
  gap:8px;
  align-items:center;
  font-weight: 400; /* not bold overall */
}

/* outcome borders: left team vs right team */
.match-card.score-win{
  box-shadow: inset 6px 0 0 rgba(21,128,61,.22), inset -6px 0 0 rgba(185,28,28,.18);
}
.match-card.score-loss{
  box-shadow: inset 6px 0 0 rgba(185,28,28,.18), inset -6px 0 0 rgba(21,128,61,.22);
}
.match-card.score-tie{
  box-shadow: inset 6px 0 0 rgba(161,98,7,.18), inset -6px 0 0 rgba(161,98,7,.18);
}

/* number pill under team name */
.elo-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:3px 10px;
  border-radius:999px;
  border:1px solid #e7edf5;
  background:#f8fafc;
  color:#475569;
  font-size:11px;
  font-weight:900;
  margin-top:4px;
}
.elo-pill.pill-win{
  border-color: rgba(21,128,61,.28);
  background: rgba(21,128,61,.10);
  color:#14532d;
}
.elo-pill.pill-loss{
  border-color: rgba(185,28,28,.28);
  background: rgba(185,28,28,.10);
  color:#7f1d1d;
}
.elo-pill.pill-tie{
  border-color: rgba(161,98,7,.28);
  background: rgba(161,98,7,.10);
  color:#78350f;
}

.match-card + .match-card{ margin-top:10px; }

.mc-left, .mc-right{ min-width:0; font-weight: inherit; }
.mc-left{ text-align:left; }
.mc-right{ text-align:right; }

.mc-name{
  line-height:1.12;
  display:flex;
  align-items:center;
  gap:6px;
  flex-wrap:wrap;
  min-width:0;
}
.mc-left .mc-name{ justify-content:flex-start; }
.mc-right .mc-name{ justify-content:flex-end; }
.mc-name .nm{ min-width:0; overflow:hidden; text-overflow:ellipsis; font-weight:900; } /* team name bold */

.mc-mid{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:4px;
  font-weight: 700;
}
.mc-score{
  font-weight:900;
  text-align:center;
  border-radius:12px;
  padding:4px 6px;
  min-width:68px;
  border:1px solid #eef2f7;
  background:#f8fafc;
  line-height:1;
  font-size:11.5px;
  color:#334155;
}

.mc-date-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid #eef2f7;
  background:#f8fafc;
  font-weight:900;
  font-size:12px;
  color:#334155;
  line-height:1;
}
.mc-score-stroke{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  font-size:15px;
}
@media (max-width: 420px){
  .mc-score-stroke{ font-size:14px; }
}

/* Adjustments form - responsive grid (prevents mobile overlap) */
.adj-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
@media (max-width: 640px){
  .adj-grid{ grid-template-columns: 1fr; }
}
/* Ensure form controls never overflow on mobile */
#adjWrap input, #adjWrap select, #adjWrap button{ box-sizing:border-box; max-width:100%; }


/* --- Match Results: plain date + plain scores (no pills) --- */
.mc-date-pill{
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  display: block !important;
}
.mc-score{
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  min-width: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  font-size: 16px !important;
  line-height: 1.1 !important;
}
/* winning/losing colors (scores only) */
.mc-scoreline .score-win, .mc-score .score-win{ color:#15803d !important; }
.mc-scoreline .score-loss, .mc-score .score-loss{ color:#b91c1c !important; }
.mc-scoreline .score-tie, .mc-score .score-tie{ color:#a16207 !important; }
/* Team names stay neutral even if a class is applied */
.mc-name .score-win, .mc-name .score-loss, .mc-name .score-tie{ color:#111 !important; }


/* Team names always neutral; only scores are colored */
.mc-side-team{ color:#111 !important; }

/* Tighten W/L columns and give TEAM more room */
thead th:nth-child(2),
thead th:nth-child(3),
tbody td:nth-child(2),
tbody td:nth-child(3){
  padding-left:6px;
  padding-right:6px;
}

</style>
</head>

<body>
<?!= include('Header'); ?>

<div class="panel">
  <div class="panel-titlebar">STANDINGS</div>

  <div class="table-wrap" style="margin-top:10px;">
    <table>
      <colgroup>
        <col style="width:56%;">
        <col style="width:8%;">
        <col style="width:8%;">
        <col style="width:28%;">
      </colgroup>
      <thead>
        <tr>
          <th style="text-align:left;">TEAM</th>
          <th>W</th>
          <th>L</th>
          <th>POINTS %</th>
        </tr>
      </thead>
      <tbody id="body">
        <tr><td colspan="4" class="small" style="padding:14px;">Loading…</td></tr>
      </tbody>
    </table>
  
  <div id="meta" class="small" style="margin-top:10px;"></div>
</div>
</div>




<details class="panel collapsible" id="matchResults">
  <summary>MATCH RESULTS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div id="results"></div>


  </div>
</details>

<details class="panel collapsible" id="bigUpsets">
  <summary>BIGGEST UPSETS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div id="upsets"></div>
  </div>
</details>

<details class="panel collapsible" id="simMatchup">
  <summary>SIMULATE MATCHUP<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div class="adj-grid">
      <div><select id="simTeamA" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select>
      </div>
      <div><select id="simTeamB" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select>
      </div>
    </div>
<div id="simOut" style="margin-top:10px;"></div>
  </div>
</details>

<details class="panel collapsible" id="adjWrap">
  <summary>PENALTY POINTS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">

        
    <div style="margin-top:10px; border-top:1px solid #eef2f7; padding-top:10px;">
            <div class="adj-grid">
        <div><div class="small">Date</div><input id="adjDate" type="date" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900;"></div>
        <div><div class="small">Add penalty points</div><select id="adjTeam" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select></div>
        <div><div class="small">Opponent team</div><select id="adjOpp" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select></div>
        <div><div class="small">Penalty Points</div><input id="adjDelta" placeholder="4" inputmode="decimal" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900;"></div>
      </div>      <div style="display:flex; gap:10px; margin-top:10px; align-items:center; flex-wrap:wrap;">
        <button id="adjSave" style="border:0; border-radius:14px; padding:10px 14px; font-weight:1000; color:#fff; background:linear-gradient(var(--btn-angle), #ff3b3b, #e40000);">SAVE</button>        <div class="small" id="adjMsg"></div>
      </div>
      <div style="margin-top:12px; border-top:1px solid #eef2f7; padding-top:12px;">
        <div id="adjList" class="small" style="padding:6px 2px;"></div>
      </div>

    </div>
  
  </div>
</details>

<script>
const $ = (id)=>document.getElementById(id);
function esc(s){ return (s==null?"":String(s)).replace(/[&<>"]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c])); }
function dispTeamName(s){ return String(s||"").replace(/^OPP\s*-\s*/i,"").trim(); }
function normTeam(s){
  return dispTeamName(s)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g," ")
    .replace(/\s+/g," ")
    .trim();
}

function pointsForMode(mode){
  mode = String(mode||"").toLowerCase().trim();
  if (mode === "singles") return 1;
  if (mode === "doubles") return 2;
  if (mode === "triples") return 3;
  return 0;
}
function pointsSplit(mode){
  const p = pointsForMode(mode);
  return p ? (p/2) : 0;
}
function fmtPts(x){
  const n = Number(x||0);
  if (!isFinite(n)) return "0";
  const v = Math.round(n*10)/10; // keep at 1 decimal max
  // strip trailing .0
  if (Math.abs(v - Math.round(v)) < 1e-9) return String(Math.round(v));
  let s = v.toFixed(1);
  if (s.endsWith(".0")) s = s.slice(0,-2);
  return s;
}

function parseDateKey(ts){
  const s = String(ts||"").trim();
  if (!s) return "";

  // mm/dd/yyyy or m/d/yyyy
  let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
  if (m){
    const mm = m[1].padStart(2,"0");
    const dd = m[2].padStart(2,"0");
    const yy = m[3];
    return `${yy}-${mm}-${dd}`;
  }

  // mm/dd/yy or m/d/yy
  m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})/);
  if (m){
    const mm = m[1].padStart(2,"0");
    const dd = m[2].padStart(2,"0");
    const y2 = Number(m[3]);
    const yy = (y2 <= 79) ? (2000 + y2) : (1900 + y2);
    return `${yy}-${mm}-${dd}`;
  }

  // yyyy-mm-dd
  const m2 = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (m2) return `${m2[1]}-${m2[2]}-${m2[3]}`;

  const d = new Date(s);
  if (!isNaN(d.getTime())){
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  return "";
}
function fmtDateShort(dk){
  const m = String(dk||"").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return dk || "";
  const yy = m[1].slice(2);
  return `${Number(m[2])}/${Number(m[3])}/${yy}`;
}
function pickOrder(team1, team2){
  // Return [left, right] by preference:
  // - If one is Flying Aces, keep it on the RIGHT (matches your example).
  // - Otherwise alphabetical.
  const a = team1.name, b = team2.name;
  const aFA = /flying\s*aces/i.test(a);
  const bFA = /flying\s*aces/i.test(b);
  if (aFA && !bFA) return [team2.key, team1.key];
  if (bFA && !aFA) return [team1.key, team2.key];
  return (a.localeCompare(b) <= 0) ? [team1.key, team2.key] : [team2.key, team1.key];
}

function computeFromMatchLog(rows, adjustments){
  const teamTotals = new Map(); // teamKey -> {name, w,l,t, points, possible}
  const matchups = new Map();   // key = dateKey|sortedPair -> {dateKey, teams: Map(teamKey->{name,pts,possible})}

  // Build adjustment map: key = dateKey|sortedPair -> [{teamKey, delta}]
  const adjMap = new Map();
  for (const a of (adjustments||[])){
    const dk = parseDateKey(a.dateKey || a.dateDisp || "");
    const t1 = normTeam(a.team||"");
    const t2 = normTeam(a.opp||"");
    if (!dk || !t1 || !t2) continue;
    const pair = [t1,t2].sort().join("|");
    const key = dk + "|" + pair;
    if (!adjMap.has(key)) adjMap.set(key, []);
    adjMap.get(key).push({ teamKey: t1, delta: Number(a.delta||0) });
  }

  function ensureLeagueTeam(teamKey, teamName){
    if (!teamTotals.has(teamKey)){
      teamTotals.set(teamKey, { key:teamKey, team:teamName, w:0, l:0, t:0, points:0, possible:0 });
    }
    return teamTotals.get(teamKey);
  }

  function ensureMatchup(dateKey, keyA, nameA, keyB, nameB){
    const pair = [keyA, keyB].sort().join("|");
    const k = (dateKey || "unknown") + "|" + pair;
    if (!matchups.has(k)){
      matchups.set(k, {
        dateKey: dateKey || "unknown",
        teams: new Map([
          [keyA, { key:keyA, name:nameA, pts:0, possible:0 }],
          [keyB, { key:keyB, name:nameB, pts:0, possible:0 }]
        ])
      });
    } else {
      const g = matchups.get(k);
      if (!g.teams.has(keyA)) g.teams.set(keyA, { key:keyA, name:nameA, pts:0, possible:0 });
      if (!g.teams.has(keyB)) g.teams.set(keyB, { key:keyB, name:nameB, pts:0, possible:0 });
    }
    return matchups.get(k);
  }

  // 1) Accumulate MatchLog rows into matchup totals (points + possible)
  for (const r of (rows||[])){
    const teamAraw = r.teamA ?? r["Team A"] ?? r.team_a ?? "";
    const teamBraw = r.teamB ?? r["Team B"] ?? r.team_b ?? "";
    const mode = (r.mode ?? r.Mode ?? "").toString().toLowerCase().trim();
    const result = (r.result ?? r.Result ?? "").toString().toUpperCase().trim();
    const ts = r.timestamp ?? r.Timestamp ?? "";

    if (!teamAraw || !teamBraw) continue;

    const pWin = pointsForMode(mode);
    if (!pWin) continue;

    const dateKey = parseDateKey(ts);
    const nameA = dispTeamName(teamAraw);
    const nameB = dispTeamName(teamBraw);
    const keyA = normTeam(teamAraw);
    const keyB = normTeam(teamBraw);

    ensureLeagueTeam(keyA, nameA);
    ensureLeagueTeam(keyB, nameB);

    const g = ensureMatchup(dateKey, keyA, nameA, keyB, nameB);
    const A = g.teams.get(keyA);
    const B = g.teams.get(keyB);

    // possible points for this row
    A.possible += pWin;
    B.possible += pWin;

    // points earned for this row
    if (result === "W"){ A.pts += pWin; }
    else if (result === "L"){ B.pts += pWin; }
    else { const half = pointsSplit(mode); A.pts += half; B.pts += half; }
  }

  // 2) Convert matchups to list, apply adjustments, then compute W/L (1 per matchup) and league totals
  const matchupList = [];

  for (const [key, g] of matchups.entries()){
    const teamArr = Array.from(g.teams.values());
    if (teamArr.length < 2) continue;

    let [leftKey, rightKey] = pickOrder(teamArr[0], teamArr[1]);
    let L = g.teams.get(leftKey);
    let R = g.teams.get(rightKey);

    // Apply adjustments to pts AND possible (both teams possible increases by abs(delta))
    const adjList = adjMap.get(key) || [];
    let lAdj = 0, rAdj = 0, possAdj = 0;
    for (const ad of adjList){
      const d = Number(ad.delta||0);
      if (!isFinite(d) || !d) continue;
      possAdj += Math.abs(d);
      if (ad.teamKey === L.key) lAdj += d;
      else if (ad.teamKey === R.key) rAdj += d;
    }
    if (lAdj) L.pts += lAdj;
    if (rAdj) R.pts += rAdj;
    if (possAdj){
      L.possible += possAdj;
      R.possible += possAdj;
    }

    // Winner always on the LEFT (after adjustments)
    if (R.pts > L.pts){
      const tmp = L; L = R; R = tmp;
    } else if (R.pts === L.pts){
      // Tie: alphabetical by team name
      if (String(R.name).localeCompare(String(L.name)) < 0){
        const tmp = L; L = R; R = tmp;
      }
    }

    const LT = ensureLeagueTeam(L.key, L.name);
    const RT = ensureLeagueTeam(R.key, R.name);

    LT.points += L.pts; LT.possible += L.possible;
    RT.points += R.pts; RT.possible += R.possible;

    if (L.pts > R.pts){ LT.w++; RT.l++; }
    else if (R.pts > L.pts){ LT.l++; RT.w++; }
    else { LT.t++; RT.t++; }

    const cls = (L.pts > R.pts) ? "score-win" : (R.pts > L.pts) ? "score-loss" : "score-tie";

    matchupList.push({
      dateKey: g.dateKey,
      dateShort: fmtDateShort(g.dateKey),
      leftTeam: L.name,
      rightTeam: R.name,
      leftPts: L.pts,
      rightPts: R.pts,
      cls
    });
  }

  const standings = Array.from(teamTotals.values()).map(s=>{
    const games = s.w + s.l + s.t;
    const winPct = games ? ((s.w + 0.5*s.t) / games) : 0;
    const pointsPct = s.possible ? (s.points / s.possible) : 0;
    return { team:s.team, key:s.key, w:s.w, l:s.l, t:s.t, points:s.points, possible:s.possible, winPct, pointsPct };
  });

  standings.sort((a,b)=>{
    if (b.winPct !== a.winPct) return b.winPct - a.winPct;
    if (b.pointsPct !== a.pointsPct) return b.pointsPct - a.pointsPct;
    if (b.points !== a.points) return b.points - a.points;
    return a.team.localeCompare(b.team);
  });

  // Oldest -> newest
  matchupList.sort((a,b)=>{
    const da = a.dateKey || "";
    const db = b.dateKey || "";
    if (da !== db) return da.localeCompare(db);
    const x = (a.leftTeam + " vs " + a.rightTeam);
    const y = (b.leftTeam + " vs " + b.rightTeam);
    return x.localeCompare(y);
  });

  const uniqueDates = new Set(matchupList.map(m=>m.dateKey)).size;
  return { standings, matchupList, matchupCount: matchupList.length, dateCount: uniqueDates };
}


function fillTeamDropdowns(standingsRows){
  const teamSel = $("adjTeam");
  const oppSel  = $("adjOpp");
  if (!teamSel || !oppSel) return;

  const teams = (standingsRows || []).map(r=>dispTeamName(r.team)).filter(Boolean);
  teams.sort((a,b)=>a.localeCompare(b));

  function setOptions(sel){
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Select team…";
    sel.appendChild(opt0);
    for (const t of teams){
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      sel.appendChild(o);
    }
  }
  setOptions(teamSel);
  setOptions(oppSel);

  // Prevent choosing same team for opp
  function enforce(){
    const tv = teamSel.value;
    Array.from(oppSel.options).forEach(o=>{
      o.disabled = (tv && o.value === tv);
    });
    if (oppSel.value === tv) oppSel.value = "";
  }
  teamSel.addEventListener("change", enforce);
  enforce();
}


// ----------------- Matchup simulator (team Elo win%) -----------------
let _teamEloMap = Object.create(null);
let _teamEloLoaded = false;
let _lastMatchups = [];

function isGas(){
  return (typeof google !== "undefined" && google.script && google.script.run);
}
function normTeam(s){
  return String(s||"").trim().toLowerCase();
}

function fillSimTeamSelects(standingsRows){
  const selA = $("simTeamA");
  const selB = $("simTeamB");
  if (!selA || !selB) return;

  const teams = (standingsRows||[]).map(r=>dispTeamName(r.team)).filter(Boolean);
  teams.sort((a,b)=>a.localeCompare(b));

  const prevA = selA.value || localStorage.getItem("fa_simA") || "";
  const prevB = selB.value || localStorage.getItem("fa_simB") || "";

  function setOptions(sel){
    sel.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "Select team…";
    sel.appendChild(o0);
    for (const t of teams){
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      sel.appendChild(o);
    }
  }
  setOptions(selA);
  setOptions(selB);

  // restore (if still available)
  selA.value = teams.includes(prevA) ? prevA : "";
  selB.value = teams.includes(prevB) ? prevB : "";

  function enforce(){
    const a = selA.value;
    Array.from(selB.options).forEach(o=>{ o.disabled = (a && o.value === a); });
    if (selB.value === a) selB.value = "";
    updateSimOut();
    if (_lastMatchups && _lastMatchups.length) renderUpsets(_lastMatchups);
  }
  selA.onchange = ()=>{ localStorage.setItem("fa_simA", selA.value||""); enforce(); };
  selB.onchange = ()=>{ localStorage.setItem("fa_simB", selB.value||""); updateSimOut(); };

  enforce();
}

function loadTeamEloAverages(){
  if (_teamEloLoaded) return;
  _teamEloLoaded = true;

  const out = $("simOut");
  if (out) out.innerHTML = `<div class="small">Loading team Elo…</div>`;

  if (!isGas()){
    if (out) out.innerHTML = `<div class="small">Team Elo unavailable (not running in Apps Script).</div>`;
    return;
  }

  runGs("faGetTeamEloAverages_v1", { includeInactive:false })
    .then(res=>{
      if (!res || res.ok === false){
        throw new Error(res && res.message ? res.message : "faGetTeamEloAverages_v1 failed");
      }
      const rows = res.rows || [];
      _teamEloMap = Object.create(null);
      rows.forEach(r=>{
        const t = String(r.team||"").trim();
        const e = Number(r.avgElo);
        if (!t || !isFinite(e)) return;
        _teamEloMap[normTeam(t)] = e;
      });
      updateSimOut();
    if (_lastMatchups && _lastMatchups.length) renderUpsets(_lastMatchups);
    })
    .catch(err=>{
      console.error(err);
      if (out) out.innerHTML = `<div class="small">Couldn’t load team Elo. Make sure PlayersDB has an <b>ELO</b> column.</div>`;
    });
}

function eloWinProb(eloA, eloB){
  // Elo logistic curve (125-point scale)
  const exp = (Number(eloB) - Number(eloA)) / 125;
  return 1 / (1 + Math.pow(10, exp));
}

function fmtPct(p){
  const n = Number(p);
  if (!isFinite(n)) return "—";
  return (Math.round(n*1000)/10).toFixed(1) + "%";
}
function fmtElo(n){
  n = Number(n);
  if (!isFinite(n)) return "—";
  return String(Math.round(n));
}

function updateSimOut(){
  const out = $("simOut");
  const selA = $("simTeamA");
  const selB = $("simTeamB");
  if (!out || !selA || !selB) return;

  const a = selA.value || "";
  const b = selB.value || "";
  if (!a || !b){
    out.innerHTML = `<div class="small">Pick two teams to see win percentages.</div>`;
    return;
  }

  if (!_teamEloLoaded || !_teamEloMap){
    out.innerHTML = `<div class="small">Loading team Elo…</div>`;
    return;
  }

  const eloA = _teamEloMap[normTeam(a)];
  const eloB = _teamEloMap[normTeam(b)];

  if (!isFinite(eloA) || !isFinite(eloB)){
    out.innerHTML = `<div class="small">Elo missing for one or both teams. (Check PlayersDB ELO values.)</div>`;
    return;
  }

  const pA = eloWinProb(eloA, eloB);
  const pB = 1 - pA;

  const hiStyle = `background:#ecfdf3; border-color:#bbf7d0; color:#15803d;`;
  const loStyle = `background:#fef2f2; border-color:#fecaca; color:#b91c1c;`;
  const tieStyle = `background:#f8fafc; border-color:#e2e8f0; color:#334155;`;

  const leftWinStyle  = (pA > pB) ? hiStyle : (pB > pA) ? loStyle : tieStyle;
  const rightWinStyle = (pB > pA) ? hiStyle : (pA > pB) ? loStyle : tieStyle;

  out.innerHTML = `
    <div class="match-card score-tie" style="grid-template-columns: 1fr 86px 1fr;">
      <div class="mc-left">
        <div class="mc-side-team">${esc(a)}</div>
        <div class="elo-pill">ELO ${esc(fmtElo(eloA))}</div>
        <div class="elo-pill" style="${leftWinStyle}">WIN ${esc(fmtPct(pA))}</div>
      </div>

      <div class="mc-mid">
        <div class="mc-score">VS</div>
      </div>

      <div class="mc-right">
        <div class="mc-side-team">${esc(b)}</div>
        <div class="elo-pill">ELO ${esc(fmtElo(eloB))}</div>
        <div class="elo-pill" style="${rightWinStyle}">WIN ${esc(fmtPct(pB))}</div>
      </div>
    </div>
  `;
}

function initSimulator(standingsRows){
  fillSimTeamSelects(standingsRows);
  loadTeamEloAverages();
  updateSimOut();
}
// -------------------------------------------------------------------

function renderStandings(rows, matchupCount){
  
  const tb = $("body");
  tb.innerHTML = "";

  if (!rows.length){
    tb.innerHTML = "<tr><td colspan='4' class='small' style='padding:14px;'>No league matches yet.</td></tr>";
    return;
  }

  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const pp = (r.pointsPct==null) ? "" : (Math.round(Number(r.pointsPct)*10000)/100).toFixed(2)+"%";
    tr.innerHTML =
      "<td style='font-weight:950; text-align:left;'>" + esc(dispTeamName(r.team)) + "</td>" +
      "<td>" + Number(r.w||0) + "</td>" +
      "<td>" + Number(r.l||0) + "</td>" +
      "<td style='font-weight:950;'><span class='pill'>" + pp + "</span></td>";
    tb.appendChild(tr);
  });
}

function renderMatchups(matchups){
  const root = $("results");
  if (!root) return;
  root.innerHTML = "";

  if (!matchups.length){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>No matchups found in MatchLog.</div>";
    return;
  }

  // Cards: left team | date | right team; under each team show total points for the date/matchup.
  for (const m of matchups){
    const card = document.createElement("div");
    card.className = "match-card " + m.cls;

    const leftCls  = (m.leftPts > m.rightPts) ? "score-win" : (m.rightPts > m.leftPts) ? "score-loss" : "score-tie";
    const rightCls = (m.rightPts > m.leftPts) ? "score-win" : (m.leftPts > m.rightPts) ? "score-loss" : "score-tie";

    card.innerHTML =
      "<div class='mc-left'>" +
        "<div class='mc-name'><span class='nm'>" + esc(m.leftTeam) + "</span></div>" +
      "</div>" +

      "<div class='mc-mid'>" +
        "<div class='mc-date-pill'>" + esc(m.dateShort || m.dateKey || "") + "</div>" +
        "<div class='mc-score mc-score-stroke'>" +
          "<span class='" + leftCls + "'>" + esc(fmtPts(m.leftPts)) + "</span>" +
          "<span style='opacity:.5;'>–</span>" +
          "<span class='" + rightCls + "'>" + esc(fmtPts(m.rightPts)) + "</span>" +
        "</div>" +
      "</div>" +

      "<div class='mc-right'>" +
        "<div class='mc-name'><span class='nm'>" + esc(m.rightTeam) + "</span></div>" +
      "</div>";

    root.appendChild(card);
  }
}


function renderUpsets(matchups){
  const root = $("upsets");
  if (!root) return;

  if (!matchups || !matchups.length){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>No matchups found.</div>";
    return;
  }

  // Rolling TEAM-ELO (matchday-level, not per individual match row).
  // This avoids "over-confidence" that happens when Elo is updated 30+ times per matchday.
  //
  // - Seed: current PlayersDB team-average Elo (same source as SIMULATE MATCHUP)
  // - Update cadence: ONE Elo update per matchup per date (batched by date)
  // - Win%: pre-match win probability from the rolling Elo at that time
  if (!_teamEloLoaded || !_teamEloMap){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>Loading team Elo…</div>";
    return;
  }

  const BASE_ELO   = 1500;
  const K_MATCHUP  = 14;  // tuned for matchday totals (keeps win% in a reasonable range)
  // Win-prob curve is eloWinProb() (125-point scale) — same as the simulator.

  // 1) Group by date so same-day matchups don’t influence each other’s pre-match Elo.
  const byDate = new Map();
  for (const m of matchups){
    const dk = String(m.dateKey || "").trim() || "unknown";
    if (!byDate.has(dk)) byDate.set(dk, []);
    byDate.get(dk).push(m);
  }

  const dates = Array.from(byDate.keys()).sort((a,b)=>{
    if (a === "unknown" && b !== "unknown") return 1;
    if (b === "unknown" && a !== "unknown") return -1;
    return a.localeCompare(b);
  });

  // teamKey -> current Elo (rolling)
  const elo = Object.create(null);

  function getSeededElo(teamName){
    const k = normTeam(teamName);
    if (!k) return BASE_ELO;
    if (isFinite(elo[k])) return elo[k];

    const seed = (_teamEloMap && isFinite(_teamEloMap[k])) ? Number(_teamEloMap[k]) : NaN;
    elo[k] = isFinite(seed) ? seed : BASE_ELO;
    return elo[k];
  }

  const upsets = [];

  // 2) Walk forward in time, batch updates within each date.
  for (const dk of dates){
    const games = byDate.get(dk) || [];
    const deltas = Object.create(null); // teamKey -> delta to apply at end of day

    for (const m of games){
      const leftTeam  = String(m.leftTeam || "").trim();
      const rightTeam = String(m.rightTeam || "").trim();
      if (!leftTeam || !rightTeam) continue;

      const kL = normTeam(leftTeam);
      const kR = normTeam(rightTeam);
      if (!kL || !kR || kL === kR) continue;

      const lp = Number(m.leftPts || 0);
      const rp = Number(m.rightPts || 0);
      if (!isFinite(lp) || !isFinite(rp)) continue;

      const eloL = getSeededElo(leftTeam);
      const eloR = getSeededElo(rightTeam);

      // Expected chance LEFT wins (pre-match)
      const pLeft = eloWinProb(eloL, eloR);

      // Actual score for LEFT (winner is usually already on the LEFT, but handle safety)
      let sLeft = 0.5;
      if (lp > rp) sLeft = 1;
      else if (lp < rp) sLeft = 0;

      // Record upset when winner's pre-match win% < 50%
      if (sLeft !== 0.5){
        const leftWon = (sLeft === 1);
        const pWin = leftWon ? pLeft : (1 - pLeft);
        if (pWin < 0.5){
          const winnerName = leftWon ? leftTeam : rightTeam;
          const loserName  = leftWon ? rightTeam : leftTeam;
          const winnerPts  = leftWon ? lp : rp;
          const loserPts   = leftWon ? rp : lp;

          upsets.push({
            dateKey: dk,
            dateShort: m.dateShort || fmtDateShort(dk),
            leftTeam: winnerName,
            rightTeam: loserName,
            leftPts: winnerPts,
            rightPts: loserPts,
            pWin: pWin
          });
        }
      }

      // Elo update (batched per date)
      const dLeft = K_MATCHUP * (sLeft - pLeft);
      deltas[kL] = (deltas[kL] || 0) + dLeft;
      deltas[kR] = (deltas[kR] || 0) - dLeft;
    }

    // Apply deltas at end of day
    for (const k in deltas){
      if (!Object.prototype.hasOwnProperty.call(deltas, k)) continue;
      if (!isFinite(elo[k])) elo[k] = BASE_ELO;
      elo[k] += deltas[k];
    }
  }

  upsets.sort((a,b)=>{
    if (a.pWin !== b.pWin) return a.pWin - b.pWin;
    if ((a.dateKey||"") !== (b.dateKey||"")) return (a.dateKey||"").localeCompare(b.dateKey||"");
    const x = (a.leftTeam + " vs " + a.rightTeam);
    const y = (b.leftTeam + " vs " + b.rightTeam);
    return x.localeCompare(y);
  });

  const top = upsets.slice(0, 10);
  if (!top.length){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>No upsets found (rolling team Elo).</div>";
    return;
  }

  let html = "<div style='display:grid; gap:10px;'>";
  let rank = 1;
  for (const u of top){
    const pct = fmtPct(u.pWin);
    html +=
      "<div class='match-card score-win' style='grid-template-columns: 1fr 86px 1fr;'>" +
        "<div class='mc-left'><div class='mc-name'><span class='nm'>" + esc(u.leftTeam) + "</span></div></div>" +
        "<div class='mc-mid'>" +
          "<div class='mc-date-pill'>" + esc(u.dateShort || u.dateKey || '') + "</div>" +
          "<div class='mc-score mc-score-stroke'>" +
            "<span class='score-win'>" + esc(fmtPts(u.leftPts)) + "</span>" +
            "<span style='opacity:.5;'>–</span>" +
            "<span class='score-loss'>" + esc(fmtPts(u.rightPts)) + "</span>" +
          "</div>" +
          "<div class='small' style='font-weight:950; letter-spacing:.02em; margin-top:2px;'>#" + (rank++) + " • WIN " + esc(pct) + "</div>" +
        "</div>" +
        "<div class='mc-right'><div class='mc-name'><span class='nm'>" + esc(u.rightTeam) + "</span></div></div>" +
      "</div>";
  }
  html += "</div>";
  root.innerHTML = html;
}

function renderAdjustments(rows){
  const el = $("adjList");
  if (!el) return;
  if (!rows || !rows.length){
    el.innerHTML = "No adjustments yet.";
    return;
  }
  const sorted = rows.slice().sort((a,b)=> (a.dateKey||"").localeCompare(b.dateKey||"") || (a.team||"").localeCompare(b.team||""));
  let html = "<div style='display:grid; gap:8px;'>";
  for (const r of sorted){
    const dk = r.dateKey || "";
    const dateKey = parseDateKey(r.dateKey || r.dateDisp || "");
    const dateLabel = dateKey ? fmtDateShort(dateKey) : "";
    const line =
      esc(dateLabel) + " • " +
      esc((r.team||"").trim()) + " vs " + esc((r.opp||"").trim()) +
      " • " + ((Number(r.delta||0) >= 0) ? "+" : "") + esc(fmtPts(r.delta));
    html += "<div style='border:1px solid #eef2f7; border-radius:14px; padding:10px; background:#fff;'>" +
              "<div style='display:flex; justify-content:space-between; gap:10px; align-items:flex-start;'>" +
                "<div style='font-weight:950;'>" + line + "</div>" +
                "<div style='display:flex; gap:8px; flex-shrink:0;'>" +
                  "<button data-edit='"+esc(r.id)+"' style='border:1px solid #e6edf5; background:#fff; border-radius:12px; padding:7px 10px; font-weight:950;'>Edit</button>" +
                  "<button data-del='"+esc(r.id)+"' style='border:1px solid rgba(185,28,28,.25); background:rgba(185,28,28,.07); color:#7f1d1d; border-radius:12px; padding:7px 10px; font-weight:950;'>Delete</button>" +
                "</div>" +
              "</div>" +
            "</div>";
  }
  html += "</div>";
  el.innerHTML = html;

  el.querySelectorAll("button[data-edit]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-edit");
      const r = rows.find(x=>String(x.id)===String(id));
      if (!r) return;
      $("adjDate").value = (parseDateKey(r.dateKey || r.dateDisp || "") || "");
      $("adjTeam").value = r.team || "";
      $("adjOpp").value = r.opp || "";
      $("adjDelta").value = String(r.delta ?? "");
      $("adjSave").setAttribute("data-id", String(r.id||""));
      $("adjMsg").textContent = "Editing adjustment…";
    });
  });

  el.querySelectorAll("button[data-del]").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const id = btn.getAttribute("data-del");
      if (!id) return;
      $("adjMsg").textContent = "Deleting…";
      try{
        const res = await runGs("faDeleteStandingsAdjustment_v1", { id });
        if (res && res.ok){
          $("adjMsg").textContent = "Deleted.";
          await reloadAdjustmentsAndRecalc();
        } else {
          $("adjMsg").textContent = (res && res.message) ? res.message : "Delete failed.";
        }
      }catch(e){
        $("adjMsg").textContent = e && e.message ? e.message : String(e);
      }
    });
  });
}

function clearAdjForm(){
  $("adjDate").value = "";
  $("adjTeam").value = "";
  $("adjOpp").value = "";
  $("adjDelta").value = "";
  $("adjSave").removeAttribute("data-id");
  $("adjMsg").textContent = "";
}

function wireAdjustmentForm(){
  const saveBtn = $("adjSave");
  if (!saveBtn) return;

  saveBtn.addEventListener("click", async ()=>{
    const id = saveBtn.getAttribute("data-id") || "";
    const dateKey = String($("adjDate").value||"").trim();
    const dateDisp = dateKey ? fmtDateShort(dateKey) : "";
    const team = String($("adjTeam").value||"").trim();
    const opp  = String($("adjOpp").value||"").trim();
    const deltaStr = String($("adjDelta").value||"").trim();
    const note = "";

    const delta = Number(deltaStr);
    if (!dateDisp || !team || !opp || !isFinite(delta)){
      $("adjMsg").textContent = "Please fill Date, Team, Opponent, and a numeric Delta.";
      return;
    }

    $("adjMsg").textContent = "Saving…";
    try{
      const res = await runGs("faUpsertStandingsAdjustment_v1", { id, dateDisp, team, opp, delta, note });
      if (res && res.ok){
        $("adjMsg").textContent = "Saved.";
        clearAdjForm();
        await reloadAdjustmentsAndRecalc();
      } else {
        $("adjMsg").textContent = (res && res.message) ? res.message : "Save failed.";
      }
    }catch(e){
      $("adjMsg").textContent = e && e.message ? e.message : String(e);
    }
  });
}

async function reloadAdjustmentsAndRecalc(){
  const adjRaw = await runGs("faGetStandingsAdjustments_v1", {});
  let adj = adjRaw;
  try{ if (typeof adj === "string") adj = JSON.parse(adj); }catch(_){}
  const adjRows = (adj && adj.ok) ? (adj.rows || []) : [];
  renderAdjustments(adjRows);

  const logRaw = await runGs("faGetMatchLogRows_v1", {});
  let log = logRaw;
  try{ if (typeof log === "string") log = JSON.parse(log); }catch(_){}
  if (!log || log.ok === false) return;

  const computed = computeFromMatchLog(log.rows || [], adjRows);
  _lastMatchups = computed.matchupList || [];
  renderStandings(computed.standings, computed.matchupCount);
  fillTeamDropdowns(computed.standings);
  initSimulator(computed.standings);
  renderMatchups(_lastMatchups);
  renderUpsets(_lastMatchups);}

// =========================================================
// NEW NATIVE FETCH ROUTER
// =========================================================
const GAS_API_URL = "https://script.google.com/macros/s/AKfycbxlyif58qdt0l90lSvHOm0TxlPffdfMqajwzhGDQlddsNNn82Bg37CGoMpjBKBuZoNK/exec"; 

async function runGs(fn, args) {
  try {
    const response = await fetch(GAS_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain' }, // text/plain prevents CORS preflight blocks
      body: JSON.stringify({ action: fn, payload: args || {} })
    });
    
    const data = await response.json();
    if (!data.ok) throw new Error(data.error);
    return data.result;
    
  } catch (err) {
    console.error("API Error in " + fn + ":", err);
    throw err;
  }
}

async function load(){
  try{
    const isAdmin = true;
    const adjWrap = $("adjWrap");
    if (adjWrap) adjWrap.style.display = "";

    // ==========================================
    // 1. INSTANT LOAD FROM PHONE MEMORY (CACHE)
    // ==========================================
    const cachedLogRaw = localStorage.getItem("fa_cache_log");
    const cachedAdjRaw = localStorage.getItem("fa_cache_adj");
    
    if (cachedLogRaw) {
      try {
        let log = JSON.parse(cachedLogRaw);
        let adj = cachedAdjRaw ? JSON.parse(cachedAdjRaw) : {rows: []};
        const adjRows = (adj && adj.ok) ? (adj.rows || []) : [];
        
        // Render instantly using old data while we wait for Google
        const computed = computeFromMatchLog(log.rows || [], adjRows);
        _lastMatchups = computed.matchupList || [];
        renderStandings(computed.standings, computed.matchupCount);
        fillTeamDropdowns(computed.standings);
        initSimulator(computed.standings);
        renderMatchups(_lastMatchups);
        renderUpsets(_lastMatchups);
        renderAdjustments(adjRows);
        wireAdjustmentForm();
      } catch(e) {
        console.warn("Cache render failed, waiting for network...", e);
      }
    }

    // ==========================================
    // 2. BACKGROUND FETCH FROM GOOGLE
    // ==========================================
    const [logRaw, adjRaw] = await Promise.all([
      runGs("faGetMatchLogRows_v1", {}),
      runGs("faGetStandingsAdjustments_v1", {})
    ]);

    let log = logRaw;
    try{ if (typeof log === "string") log = JSON.parse(log); }catch(_){}
    if (!log || log.ok === false) throw new Error((log && log.message) ? log.message : "MatchLog load failed.");

    let adj = adjRaw;
    try{ if (typeof adj === "string") adj = JSON.parse(adj); }catch(_){}
    const adjRows = (adj && adj.ok) ? (adj.rows || []) : [];

    // Save the fresh data to the phone's memory for next time!
    localStorage.setItem("fa_cache_log", JSON.stringify(log));
    localStorage.setItem("fa_cache_adj", JSON.stringify(adj));

    // ==========================================
    // 3. SILENTLY UPDATE THE UI WITH FRESH DATA
    // ==========================================
    const computed = computeFromMatchLog(log.rows || [], adjRows);
    _lastMatchups = computed.matchupList || [];
    renderStandings(computed.standings, computed.matchupCount);
    fillTeamDropdowns(computed.standings);
    initSimulator(computed.standings);
    renderMatchups(_lastMatchups);
    renderUpsets(_lastMatchups);
    renderAdjustments(adjRows);
    wireAdjustmentForm();

  }catch(err){
    const metaEl = $("meta");
    if (metaEl) metaEl.textContent = "Load failed: " + (err && err.message ? err.message : err);
    console.error(err);
  }
}
load();
</script>


</body>
</html>


