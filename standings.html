<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="robots" content="noindex, nofollow">
<title>Standings</title>

<style>
:root{ font-size: 12.5px; --btn-angle:135deg; }
html, body{
  margin:0; padding:0;
  background:#f7f8fa; color:#222;
  font-family:"Segoe UI", Roboto, Arial, sans-serif;
  -webkit-text-size-adjust:100%;
  text-size-adjust:100%;
}
body { padding: 10px;
  padding-bottom: calc(16px + env(safe-area-inset-bottom));
  overflow-x:hidden;
}

/* panels */
.panel{
  background:#fff;
  border-radius:18px;
  box-shadow:0 10px 30px rgba(0,0,0,.08);
  padding:14px;
  margin:12px 0;
}
.h2{ font-size:14px; font-weight:950; margin:0 0 10px; text-transform:uppercase; letter-spacing:.02em; }
.small{ font-size:11px; color:#667085; font-weight:800; }

/* table */
.table-wrap{ overflow-x:auto; -webkit-overflow-scrolling:touch; }
table{ width:100%; border-collapse:collapse; table-layout:fixed; }
thead th{
  font-size:11px;
  letter-spacing:.06em;
  color:#4b5563;
  padding:10px 10px;
  border-bottom:1px solid #eef2f7;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  text-transform:uppercase;
  text-align:center;
}
tbody td{
  padding:10px 10px;
  border-bottom:1px solid #f1f5f9;
  font-size:13px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* Column widths (mobile-friendly) */
thead th:nth-child(1), tbody td:nth-child(1){ width:38%; text-align:left; }
thead th:nth-child(2), tbody td:nth-child(2){ width:8%; }
thead th:nth-child(3), tbody td:nth-child(3){ width:8%; }
thead th:nth-child(4), tbody td:nth-child(4){ width:14%; }
thead th:nth-child(5), tbody td:nth-child(5){ width:14%; }
thead th:nth-child(6), tbody td:nth-child(6){ width:18%; }

/* Prevent PS/PA/% truncation */
thead th:nth-child(2), thead th:nth-child(3), thead th:nth-child(4), thead th:nth-child(5), thead th:nth-child(6),
tbody td:nth-child(2), tbody td:nth-child(3), tbody td:nth-child(4), tbody td:nth-child(5), tbody td:nth-child(6){
  overflow:visible;
  text-overflow:clip;
}
tbody td:first-child{ text-align:left; }
thead th:nth-child(n+2),
tbody td:nth-child(n+2){ text-align:center; }

.pill{
  display:inline-flex;
  align-items:center;
  padding:4px 9px;
  border-radius:999px;
  background:#f1f5f9;
  font-weight:900;
  color:#111827;
  font-size:11.5px;
}

/* Non-collapsible header that matches the collapsible <summary> look (RED like active pages) */
.panel-titlebar{
  display:flex;
  align-items:center;
  justify-content:center;
  margin:-14px -14px 12px;
  height:32px;
  padding:0 14px;
  box-sizing:border-box;
  text-transform:uppercase;
  font-weight:950;
  font-size:14px;
  letter-spacing:.02em;
  user-select:none;
  background: linear-gradient(var(--btn-angle), #ff3b3b, #e40000);
  color:#fff;
  border-top-left-radius:18px;
  border-top-right-radius:18px;
}

/* Collapsible panels (same feel as Stats page) */
details.collapsible{ padding:0; }
details.collapsible > summary{
  display:flex;
  align-items:center;
  justify-content:center;
  padding:12px 14px;
  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color: transparent;
  font-weight:950;
  font-size:14px;
  letter-spacing:.02em;
  text-transform:uppercase;
  position:relative;
  list-style:none;
}
details.collapsible > summary::-webkit-details-marker{ display:none; }
details.collapsible .collap-chevron{
  position:absolute;
  right:14px;
  top:50%;
  transform:translateY(-50%) rotate(0deg);
  transition: transform 180ms ease;
  font-size:18px;
  color:#667085;
}
details.collapsible[open] .collap-chevron{ transform: translateY(-50%) rotate(180deg); }
details.collapsible .collap-body{ padding:0 14px 14px; }
details.collapsible .detailsBody{ padding:0 14px 14px; }

/* =========================================================
   Match-card styling (from your Stats match cards)
   ========================================================= */
.match-card{
  background:#fff;
  border:1px solid #eef2f7;
  border-radius:16px;
  padding:8px 10px;
  display:grid;
  grid-template-columns: 1fr 86px 1fr;
  gap:8px;
  align-items:center;
  font-weight: 400; /* not bold overall */
}

/* outcome borders: left team vs right team */
.match-card.score-win{
  box-shadow: inset 6px 0 0 rgba(21,128,61,.22), inset -6px 0 0 rgba(185,28,28,.18);
}
.match-card.score-loss{
  box-shadow: inset 6px 0 0 rgba(185,28,28,.18), inset -6px 0 0 rgba(21,128,61,.22);
}
.match-card.score-tie{
  box-shadow: inset 6px 0 0 rgba(161,98,7,.18), inset -6px 0 0 rgba(161,98,7,.18);
}

/* number pill under team name */
.elo-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:3px 10px;
  border-radius:999px;
  border:1px solid #e7edf5;
  background:#f8fafc;
  color:#475569;
  font-size:11px;
  font-weight:900;
  margin-top:4px;
}
.elo-pill.pill-win{
  border-color: rgba(21,128,61,.28);
  background: rgba(21,128,61,.10);
  color:#14532d;
}
.elo-pill.pill-loss{
  border-color: rgba(185,28,28,.28);
  background: rgba(185,28,28,.10);
  color:#7f1d1d;
}
.elo-pill.pill-tie{
  border-color: rgba(161,98,7,.28);
  background: rgba(161,98,7,.10);
  color:#78350f;
}

.match-card + .match-card{ margin-top:10px; }

.mc-left, .mc-right{ min-width:0; font-weight: inherit; }
.mc-left{ text-align:left; }
.mc-right{ text-align:right; }

.mc-name{
  line-height:1.12;
  display:flex;
  align-items:center;
  gap:6px;
  flex-wrap:wrap;
  min-width:0;
}
.mc-left .mc-name{ justify-content:flex-start; }
.mc-right .mc-name{ justify-content:flex-end; }
.mc-name .nm{ min-width:0; overflow:hidden; text-overflow:ellipsis; font-weight:900; } /* team name bold */

.mc-mid{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:4px;
  font-weight: 700;
}
.mc-score{
  font-weight:900;
  text-align:center;
  border-radius:12px;
  padding:4px 6px;
  min-width:68px;
  border:1px solid #eef2f7;
  background:#f8fafc;
  line-height:1;
  font-size:11.5px;
  color:#334155;
}

.mc-date-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid #eef2f7;
  background:#f8fafc;
  font-weight:900;
  font-size:12px;
  color:#334155;
  line-height:1;
}
.mc-score-stroke{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  font-size:15px;
}
@media (max-width: 420px){
  .mc-score-stroke{ font-size:14px; }
}

/* Adjustments form - responsive grid (prevents mobile overlap) */
.adj-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
@media (max-width: 640px){
  .adj-grid{ grid-template-columns: 1fr; }
}
/* Ensure form controls never overflow on mobile */
#adjWrap input, #adjWrap select, #adjWrap button{ box-sizing:border-box; max-width:100%; }


/* --- Match Results list ONLY: plain date + plain scores (no pills) --- */
#results .mc-date-pill, #upsets .mc-date-pill{
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  display: block !important;
}
#results .mc-score, #upsets .mc-score{
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  min-width: 0 !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  font-size: 16px !important;
  line-height: 1.1 !important;
}
/* winning/losing colors (scores only) */
#results .mc-scoreline .score-win, #results .mc-score .score-win, #upsets .mc-scoreline .score-win, #upsets .mc-score .score-win{ color:#15803d !important; }
#results .mc-scoreline .score-loss, #results .mc-score .score-loss, #upsets .mc-scoreline .score-loss, #upsets .mc-score .score-loss{ color:#b91c1c !important; }
#results .mc-scoreline .score-tie, #results .mc-score .score-tie, #upsets .mc-scoreline .score-tie, #upsets .mc-score .score-tie{ color:#a16207 !important; }
/* Team names stay neutral even if a class is applied */
#results .mc-name .score-win, #results .mc-name .score-loss, #results .mc-name .score-tie, #upsets .mc-name .score-win, #upsets .mc-name .score-loss, #upsets .mc-name .score-tie{ color:#111 !important; }

/* Team names always neutral; only scores are colored */
#results .mc-side-team, #upsets .mc-side-team{ color:#111 !important; }

/* Tighten W/L/PS/PA columns and give TEAM more room */
thead th:nth-child(2),
thead th:nth-child(3),
thead th:nth-child(4),
thead th:nth-child(5),
tbody td:nth-child(2),
tbody td:nth-child(3),
tbody td:nth-child(4),
tbody td:nth-child(5){
  padding-left:6px;
  padding-right:6px;
}


/* =========================
   Match Results month headers
   ========================= */
.month-section{ margin-top: 6px; }
.month-head{
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:8px 10px;
  border-radius:14px;
  border:1px solid #eef2f7;
  background:#f8fafc;
  font-weight:950;
  letter-spacing:.04em;
  text-transform:uppercase;
  color:#334155;
  margin:12px 0 10px;
}
.month-sub{
  font-size:10px;
  font-weight:900;
  color:#667085;
  letter-spacing:.06em;
}

/* Make Match Results cards feel tappable */
#results .match-card{
  cursor:pointer;
  -webkit-tap-highlight-color: transparent;
}

/* =========================
   Modal (sheet style)
   ========================= */
.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.46);
  display:none;
  align-items:flex-end;
  justify-content:center;
  padding:12px;
  z-index: 99999;
}
.modal.show{ display:flex; }
.modal-card{
  width:100%;
  max-width:560px;
  background:#fff;
  border-radius:18px;
  box-shadow:0 20px 60px rgba(0,0,0,.35);
  overflow:hidden;
  border:1px solid rgba(255,255,255,.5);
}
.modal-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:12px 14px;
  border-bottom:1px solid #eef2f7;
}
.modal-head .title{
  font-weight:950;
  letter-spacing:.02em;
  text-transform:uppercase;
  font-size:13px;
  color:#111827;
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.icon-btn{
  border:1px solid #e5e7eb;
  background:#fff;
  width:34px;
  height:34px;
  border-radius:12px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:22px;
  line-height:1;
  color:#111;
}
.modal-body{
  padding:12px 14px;
  max-height: calc(100vh - 150px);
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}

/* quick form row inside modal */
.modal-meta{
  display:flex;
  gap:10px;
  align-items:flex-end;
  flex-wrap:wrap;
  margin-bottom:10px;
}
.modal-meta .field{ display:flex; flex-direction:column; gap:6px; }
.modal-meta .label{ font-size:10px; font-weight:950; color:#667085; letter-spacing:.06em; text-transform:uppercase; }
.modal-meta select{
  height:36px;
  border-radius:12px;
  border:1px solid #e5e7eb;
  padding:0 10px;
  font-weight:900;
  background:#fff;
}

/* player layout for modal match cards */
.mc-player{
  display:flex;
  flex-direction:column;
  gap:2px;
  min-width:0;
}
.mc-right .mc-player{ align-items:flex-end; }
.mc-left  .mc-player{ align-items:flex-start; }
.mc-player-name{
  font-weight:900;
  line-height:1.12;
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  max-width:100%;
}

.mc-player-stack{
  display:flex;
  flex-direction:column;
  gap:2px;
  font-weight:900;
  line-height:1.12;
  min-width:0;
  max-width:100%;
}
.mc-player-stack .mc-player-line{
  min-width:0;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.mc-player.right{ align-items:flex-end; text-align:right; }
.mc-player-stack.right{ align-items:flex-end; text-align:right; }

.mc-team-tag{
  font-size:10px;
  font-weight:900;
  color:#667085;
  letter-spacing:.02em;
  white-space:nowrap;
}
.mc-mode-tag{
  font-size:10px;
  font-weight:950;
  color:#667085;
  letter-spacing:.06em;
  text-transform:uppercase;
}

</style>
</head>

<body>
<style>
:root{ --fa-header-offset: 0px; }

/* Header container */
.fa-header{
  position: sticky;
  top: 0;
  z-index: 1000;
  background: #f7f8fa;
  border-bottom: none;
  padding: 0 !important;
  box-sizing: border-box;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

/* ✅ Help block pinch/zoom gestures inside iframe (browser-dependent) */
html, body { touch-action: pan-x pan-y; }

/* ============ TOP TABS (4) ============ */
.fa-header .fa-tabs{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 6px !important;
  padding: 8px 0 !important;
  margin: 0 !important;
  border: none !important;
  background: transparent !important;
  border-radius: 0 !important;
}

/* Shared button base for top tabs + submenu buttons */
.fa-header .fa-tabs button,
.fa-header .fa-submenu button{
  -webkit-appearance:none !important;
  appearance:none !important;

  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  width:100% !important;
  box-sizing:border-box !important;

  font-family:"Segoe UI", Roboto, Arial, sans-serif !important;
  font-weight:900 !important;
  font-size: clamp(12px, 3.6vw, 16px) !important;
  letter-spacing: .2px !important;
  line-height: 1 !important;

  height: 40px !important;
  min-height: 40px !important;
  padding: 0 6px !important;

  border-radius: 8px !important;
  border: 0 !important;
  outline: none !important;

  background: linear-gradient(180deg, #f9f9f9 0%, #ededed 100%) !important;
  box-shadow: 0 1px 4px rgba(0,0,0,.10) !important;

  color: #222 !important;
  cursor: pointer !important;

  transition: background .18s ease, color .18s ease, box-shadow .18s ease, transform .08s ease, filter .12s ease !important;

  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;

  -webkit-tap-highlight-color: transparent !important;
  user-select: none !important;
}

.fa-header .fa-tabs button:not(.active):hover,
.fa-header .fa-submenu button:not(.sub-active):hover{
  background: linear-gradient(180deg, #f1f1f1 0%, #e3e7f0 100%) !important;
}

/* Active tab */
.fa-header .fa-tabs button.active{
  background: linear-gradient(135deg,#ff3b3b 0%, #e40000 100%) !important;
  color: #ffffff !important;
  box-shadow: 0 1px 6px rgba(228,0,0,.22) !important;
  filter: brightness(1.06);
}

/* Tap flash */
.fa-header .fa-tabs button.fa-press,
.fa-header .fa-submenu button.fa-press{
  background: linear-gradient(135deg,#ff3b3b 0%, #e40000 100%) !important;
  color: #ffffff !important;
  box-shadow: 0 1px 6px rgba(228,0,0,.22) !important;
  filter: brightness(1.06);
}

.fa-header .fa-tabs button:active,
.fa-header .fa-submenu button:active{
  transform: scale(0.99);
}

/* ======= Hamburger button + logo ======= */
#nav-menu{
  padding: 0 10px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 10px !important;
}

#nav-menu .menu-logo{
  height: 18px;
  width: auto;
  display: block;
}

#nav-menu .hamburger-icon{
  width: 24px;
  height: 24px;
  flex: 0 0 auto;
}
#nav-menu .hamburger-icon{
  width: 24px;
  height: 24px;
  flex: 0 0 auto;
}

/* ============ DROPDOWN MENU (hamburger) ============ */
.fa-submenu-wrap{ position: relative; }

.fa-submenu{
  position: absolute;
  top: 100%;
  left: 0;
  padding: 8px 0 0;
  z-index: 1001;

  opacity: 0;
  transform: translateY(-6px);
  visibility: hidden;
  pointer-events: none;
  transition: opacity 140ms ease, transform 140ms ease, visibility 0s linear 140ms;
}
.fa-submenu.show{
  opacity: 1;
  transform: translateY(0);
  visibility: visible;
  pointer-events: auto;
  transition: opacity 140ms ease, transform 140ms ease;
}

.fa-submenu .inner{
  background: rgba(255,255,255,.98);
  border: 1px solid rgba(0,0,0,.12);
  box-shadow: 0 12px 26px rgba(0,0,0,.16);
  border-radius: 14px;
  overflow: hidden;
  padding: 8px;

  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;

  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}

/* Slightly taller menu rows feels more “iOS” without changing your top tabs */
.fa-header .fa-submenu button{
  height: 42px !important;
  min-height: 42px !important;
  font-size: 13px !important;
  border-radius: 12px !important;
}

.fa-header .fa-submenu button.sub-active{
  background: linear-gradient(135deg,#ff3b3b 0%, #e40000 100%) !important;
  color:#fff !important;
  box-shadow: 0 1px 6px rgba(228,0,0,.22) !important;
  filter: brightness(1.04);
}

@media (max-width: 420px){
  .fa-header .fa-tabs{ padding: 6px 0 !important; }
  .fa-header .fa-tabs button{
    height: 36px !important;
    min-height: 36px !important;
    font-size: 13px !important;
    padding: 0 6px !important;
  }
  .fa-header .fa-submenu button{
    height: 40px !important;
    min-height: 40px !important;
    font-size: 12.5px !important;
  }
  #nav-menu .hamburger-icon{
    width: 22px;
    height: 22px;
  }
}
@media (max-width: 420px){
  #nav-menu .menu-logo{ height: 16px; }
  #nav-menu .hamburger-icon{ width: 22px; height: 22px; }
}
/* =========================================================
   Pull-to-refresh toast (spinner-only pill)
   ========================================================= */
#fa-ptr{
  position: fixed;
  left: 50%;
  top: calc(env(safe-area-inset-top) + 10px);
  transform: translate(-50%, -14px);
  opacity: 0;
  z-index: 99999;
  pointer-events: none;

  display: inline-flex;
  align-items: center;
  justify-content: center;

  padding: 10px 12px;
  border-radius: 999px;

  background: rgba(255,255,255,.92);
  border: 1px solid rgba(0,0,0,.12);
  box-shadow: 0 6px 18px rgba(0,0,0,.12);

  transition: opacity 140ms ease, transform 140ms ease;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
}
#fa-ptr.show{ opacity: 1; transform: translate(-50%, 0); }
#fa-ptr .spin{
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid rgba(0,0,0,.18);
  border-top-color: rgba(0,0,0,.55);
  animation: faSpin 800ms linear infinite;
}
@keyframes faSpin { to { transform: rotate(360deg); } }
</style>

<div class="fa-header fa-submenu-wrap">
<nav class="fa-tabs">
<button data-page="scoring" id="nav-scoring" type="button">SCORING</button>
<button data-page="rosters" id="nav-rosters" type="button">ROSTERS</button>
<button data-page="matchups" id="nav-matchups" type="button">MATCHUPS</button>
<!-- Hamburger -->
<button aria-expanded="false" aria-label="More" data-key="menu" id="nav-menu" type="button">
<img alt="" aria-hidden="true" class="menu-logo" decoding="async" loading="eager" src="https://lufberydiscgolf.com/wp-content/uploads/2025/05/lufberyflyingace_logo-1.png?w=64&amp;h=32"/>
<svg aria-hidden="true" class="hamburger-icon" viewbox="0 0 24 24">
<path d="M4 7h16M4 12h16M4 17h16" fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2.6"></path>
</svg>
</button>
</nav>
<!-- Dropdown (anchored under hamburger) -->
<div aria-hidden="true" class="fa-submenu" id="faMoreMenu">
<div class="inner">
<button data-page="rankings">RANKINGS</button>
<button data-page="stats">STATS</button>
<button data-page="elo">ELO</button>
<button data-page="standings">STANDINGS</button>
<button data-page="admin">ADMIN</button>
</div>
</div>
</div>
<script>
/* ===========================
   0) Disable pinch/zoom inside iframe (iOS Safari fallback)
   =========================== */
(function(){
  ['gesturestart','gesturechange','gestureend'].forEach(function(evt){
    document.addEventListener(evt, function(e){ e.preventDefault(); }, { passive:false });
  });

  var lastTouchEnd = 0;

  function _faIsIOS_(){
    try{
      var ua = navigator.userAgent || "";
      var plat = navigator.platform || "";
      var isIPhoneIPadIPod = /iPad|iPhone|iPod/.test(ua);
      var isIPadOS = (plat === "MacIntel" && (navigator.maxTouchPoints || 0) > 1);
      return isIPhoneIPadIPod || isIPadOS;
    }catch(_){ return false; }
  }
  function _faIsInteractive_(t){
    try{
      return !!(t && t.closest && t.closest("button,a,input,select,textarea,label,[role='button'],[contenteditable='true']"));
    }catch(_){ return false; }
  }

  document.addEventListener('touchend', function(e){
    if (!_faIsIOS_()) return;
    if (_faIsInteractive_(e.target)) return;

    var now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive:false });
})();

/* ===========================
   1) Header nav + menu + active state
   =========================== */
(function(){
  function qs() {
    try { return new URLSearchParams(window.location.search || ""); }
    catch (e) { return new URLSearchParams(""); }
  }

  function currentPage(){
    var p = (qs().get("p") || qs().get("page") || "").toLowerCase();

    // Support hash routing (GitHub wrapper uses #scoring, #matchups, etc.)
    if (!p){
      var h = (window.location.hash || "").replace(/^#/, "").toLowerCase();
      h = h.replace(/^\/+/, "");
      if (h.indexOf("?") !== -1) h = h.split("?")[0];
      if (h.indexOf("&") !== -1) h = h.split("&")[0];
      p = h;
    }

    // Support clean-path routing (/rosters, /matchups, etc.)
    if (!p){
      var path = (window.location.pathname || "").toLowerCase();
      path = path.replace(/\/+$/, ""); // trim trailing slash
      if (path && path !== "/"){
        var seg = path.split("/").filter(Boolean).pop() || "";
        seg = seg.replace(/\.html$/, "");
        p = seg;
      }
    }

    if (!p) return "matchups";
    if (p === "doubles") p = "rosters";
    return p;
  }

  function isEmbedded(){
    try { if (window.top !== window) return true; } catch(e){ return true; }
    return false;
  }

  // Pages that live under the hamburger menu
  const menuPages = ['rankings','stats','standings','elo','admin','players'];

  function setActiveByPage(page){
    page = String(page||"").toLowerCase();

    // top tabs
    document.querySelectorAll(".fa-tabs button").forEach(function(b){
      var key = b.dataset.key || b.dataset.page || "";
      var active = false;
      if (key === "menu") active = (menuPages.indexOf(page) !== -1);
      else active = (b.dataset.page === page);
      b.classList.toggle("active", !!active);
    });

    // dropdown buttons
    var menu = document.getElementById("faMoreMenu");
    if (menu){
      menu.querySelectorAll("button[data-page]").forEach(function(btn){
        btn.classList.toggle("sub-active", (btn.dataset.page === page));
      });
    }
  }

  function detectActive(){
    try{
      var p = currentPage();
      if (menuPages.indexOf(p) !== -1 || ["scoring","rosters","matchups"].indexOf(p) !== -1){
        setActiveByPage(p);
        return;
      }
      
      // STATS title marker (helps when Stats page also contains roster/link sections)
      var titleBar = document.querySelector(".pageTitlePanel .panel-titlebar, .panel.pageTitlePanel .panel-titlebar, .panel-titlebar");
      if (titleBar && /stats/i.test((titleBar.textContent || "").trim())){
        setActiveByPage("stats");
        return;
      }

// ELO markers
      if (
        document.getElementById("kBase") ||
        document.getElementById("overallBody") ||
        document.getElementById("pairsBody") ||
        /(^|\s)elo(\s|$)/i.test(document.title || "")
      ){
        setActiveByPage("elo");
        return;
      }

      // DOM heuristics
      if (document.getElementById("singlesBody") || document.getElementById("recentCards")) { setActiveByPage("stats"); return; }
      if (document.getElementById("table-body")) { setActiveByPage("rankings"); return; }
      if (document.getElementById("b1") || document.getElementById("b2") || document.getElementById("b9")) { setActiveByPage("scoring"); return; }
      if (document.getElementById("panel-CURRENT")) { setActiveByPage("rosters"); return; }
      if (document.getElementById("playersTable") || document.getElementById("teamSelect")) { setActiveByPage("admin"); return; }
      if (document.getElementById("team1Table") || document.getElementById("team2Table")) { setActiveByPage("matchups"); return; }
      // Standings markers
      if (document.getElementById("matchResults") || document.getElementById("adjWrap") || document.getElementById("simMatchup")) { setActiveByPage("standings"); return; }

      // title fallback
      var t = (document.title || "").toLowerCase();
      if (t.indexOf("stat") !== -1) { setActiveByPage("stats"); return; }
      if (t.indexOf("ranking") !== -1) { setActiveByPage("rankings"); return; }
      if (t.indexOf("scor") !== -1) { setActiveByPage("scoring"); return; }
      if (t.indexOf("roster") !== -1 || t.indexOf("double") !== -1) { setActiveByPage("rosters"); return; }

      setActiveByPage("matchups");
    }catch(e){
      setActiveByPage("matchups");
    }
  }

  function extraQS(opts){
    opts = opts || {};
    var s = qs();
    var parts = [];
    // Only propagate embed=1 when actually inside an iframe
    if (opts.embed && isEmbedded()) parts.push("embed=1");
    var scale = s.get("scale");
    var v = s.get("v");
    if (scale) parts.push("scale=" + encodeURIComponent(scale));
    if (v) parts.push("v=" + encodeURIComponent(v));
    return parts.length ? ("?" + parts.join("&")) : "";
  }

  function buildHref(page){
    page = String(page||"").toLowerCase();
    if (!page) return "";
    if (isEmbedded()){
      var q = extraQS({ embed:true });
      if (q) q = q.replace(/^\?/, "&");
      return "?p=" + encodeURIComponent(page) + q;
    } else {
      return "/" + encodeURIComponent(page) + ".html" + extraQS({ embed:false });
    }
  }

  function maybeRedirectLegacyParams(){
    if (isEmbedded()) return;
    var s = qs();
    var p = (s.get("p") || s.get("page") || "").toLowerCase();
    if (!p) return;

    var target = "/" + encodeURIComponent(p) + ".html";
    var cur = (window.location.pathname || "").toLowerCase().replace(/\/+/g, "/");
    if (cur.endsWith("/")) cur = cur.slice(0, -1);
    if (cur === target.toLowerCase()) return;

    var q2 = extraQS({ embed:false });
    try{
      window.location.replace(q2 ? (target + q2) : target);
    }catch(e){
      window.location.href = q2 ? (target + q2) : target;
    }
  }

  

  function sendToWrapper(page){
    var msg = { type: "FA_NAV", page: page };
    var sent = false;
    try { window.top.postMessage(msg, "*"); sent = true; } catch(e){}
    try {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage(msg, "*");
        sent = true;
      }
    } catch(e){}
    return sent;
  }

  // ---- menu open/close ----
  var menuBtn  = document.getElementById("nav-menu");
  var menuEl   = document.getElementById("faMoreMenu");

  function setMenuAria(open){
    if (!menuBtn) return;
    menuBtn.setAttribute("aria-expanded", open ? "true" : "false");
  }

  function positionMenu(){
    if (!menuEl || !menuBtn) return;
    var wrap = document.querySelector(".fa-submenu-wrap");
    if (!wrap) return;

    var wrapRect = wrap.getBoundingClientRect();
    var btnRect  = menuBtn.getBoundingClientRect();

    // Wider than the button for a “real site” menu feel
    var width = Math.max(btnRect.width + 12, 200);
    width = Math.min(width, Math.floor(wrapRect.width - 8));

    // Right-align under the hamburger (more typical)
    var left = (btnRect.right - wrapRect.left) - width;

    // Clamp within wrap bounds
    var maxLeft = Math.max(0, wrapRect.width - width);
    left = Math.max(0, Math.min(left, maxLeft));

    menuEl.style.left = left + "px";
    menuEl.style.right = "auto";
    menuEl.style.width = width + "px";
  }

  function openMenu(){
    if (!menuEl) return;
    positionMenu();
    menuEl.classList.add("show");
    menuEl.setAttribute("aria-hidden","false");
    setMenuAria(true);
  }

  function closeMenu(){
    if (!menuEl) return;
    menuEl.classList.remove("show");
    menuEl.setAttribute("aria-hidden","true");
    setMenuAria(false);
  }

  function toggleMenu(){
    if (!menuEl) return;
    if (menuEl.classList.contains("show")) closeMenu();
    else openMenu();
  }

  function navigate(page){
    page = String(page||"").toLowerCase();
    if (!page) return;

    closeMenu();

    // Active immediately so tap feels responsive
    setActiveByPage(page);

    var embedded = isEmbedded();
    if (embedded){
      var ok = sendToWrapper(page);
      if (!ok) window.location.href = buildHref(page);
    }else{
      window.location.href = buildHref(page);
    }
  }

  // Close on outside click
  document.addEventListener("click", function(e){
    if (!menuEl || !menuEl.classList.contains("show")) return;
    var t = e.target;
    if (t === menuBtn || (menuBtn && menuBtn.contains(t))) return;
    if (menuEl.contains(t)) return;
    closeMenu();
  }, true);

  // Keep menu anchored on resize/orientation changes
  window.addEventListener("resize", function(){
    if (menuEl && menuEl.classList.contains("show")) positionMenu();
  }, { passive:true });

  // ESC closes
  document.addEventListener("keydown", function(e){
    if (e.key === "Escape") closeMenu();
  });

  // Tap flash
  function flash(btn){
    if (!btn) return;
    btn.classList.add("fa-press");
    window.setTimeout(function(){ btn.classList.remove("fa-press"); }, 140);
  }
  function wireFlash(root){
    if (!root) return;
    root.querySelectorAll("button").forEach(function(btn){
      btn.addEventListener("touchstart", function(){ flash(btn); }, { passive:true });
      btn.addEventListener("mousedown",  function(){ flash(btn); }, { passive:true });
    });
  }
  wireFlash(document.querySelector(".fa-tabs"));
  wireFlash(menuEl);

  // Wire top tabs
  document.querySelectorAll(".fa-tabs button").forEach(function(btn){
    btn.addEventListener("click", function(){
      if (btn.id === "nav-menu"){ toggleMenu(); return; }
      var page = btn.dataset.page;
      if (page) navigate(page);
    });
  });

  // Wire dropdown
  if (menuEl){
    menuEl.querySelectorAll("button[data-page]").forEach(function(btn){
      btn.addEventListener("click", function(){
        navigate(btn.dataset.page);
      });
    });
  }

  // Expose helpers
  try { window.faNavigate = navigate; } catch(e){}
  try { window.navigate = navigate; } catch(e){}
  try { window.faSetActiveByPage = setActiveByPage; } catch(e){}
  try { window.faDetectActive = detectActive; } catch(e){}

  // Keep active tab in sync for hash-routed / SPA navigation
  window.addEventListener("hashchange", function(){ setTimeout(detectActive, 0); }, { passive:true });
  window.addEventListener("popstate",  function(){ setTimeout(detectActive, 0); }, { passive:true });
  try{
    ["pushState","replaceState"].forEach(function(fn){
      var orig = history[fn];
      if (!orig) return;
      history[fn] = function(){
        var r = orig.apply(this, arguments);
        setTimeout(detectActive, 0);
        return r;
      };
    });
  }catch(_){ }

  maybeRedirectLegacyParams();
  detectActive();
  setMenuAria(false);

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(detectActive, 0); });
  } else {
    setTimeout(detectActive, 0);
  }
})();

/* ===========================
   2) Pull-to-refresh (unchanged)
   =========================== */
(function(){
  function isEmbedded(){
    try { return window.top !== window; } catch(e){ return true; }
  }

  function scrollTop(){
    var se = document.scrollingElement || document.documentElement || document.body;
    return se ? (se.scrollTop || 0) : 0;
  }

  function headerBottom(){
    var h = document.querySelector(".fa-header");
    if (!h) return 0;
    var r = h.getBoundingClientRect();
    return r ? (r.bottom || r.height || 0) : 0;
  }

  function isInteractiveTarget(el){
    if (!el) return false;
    return !!el.closest("button,a,input,select,textarea,label,[role='button'],[contenteditable='true'],[data-no-ptr]");
  }

  function _isVisible_(el){
    try{
      if (!el) return false;
      var cs = getComputedStyle(el);
      if (cs.display === "none" || cs.visibility === "hidden") return false;
      if (parseFloat(cs.opacity || "1") === 0) return false;
      var r = el.getBoundingClientRect();
      return !!(r && r.width > 0 && r.height > 0);
    }catch(_){ return false; }
  }

  function inModalOrOverlay(el){
    try{
      return !!(el && el.closest && el.closest(
        "[data-no-ptr],[aria-modal='true'],[role='dialog'],[role='alertdialog'],dialog,.modal,.dialog,.overlay"
      ));
    }catch(_){ return false; }
  }

  function isModalOpen(){
    try{
      if (document.body && document.body.classList && document.body.classList.contains("modal-open")) return true;

      // Any visible dialog/modal/overlay element that is positioned above content
      var nodes = document.querySelectorAll("[aria-modal='true'],dialog[open],[role='dialog'],[role='alertdialog'],.modal,.dialog,.overlay");
      for (var i=0; i<nodes.length; i++){
        var n = nodes[i];
        if (!n || (n.classList && n.classList.contains("fa-header"))) continue;
        if (!_isVisible_(n)) continue;
        var cs = getComputedStyle(n);
        if (cs.position === "fixed" || cs.position === "absolute") return true;
      }
    }catch(_){}
    return false;
  }

  var toast;

  function ensureToast(){
    if (toast) return true;
    if (!document.body) return false;
    toast = document.createElement("div");
    toast.id = "fa-ptr";
    toast.innerHTML = '<span class="spin"></span>';
    document.body.appendChild(toast);
    return true;
  }

  function showToast(){
    if (!ensureToast()) return;
    toast.classList.add("show");
  }

  function hideToast(){
    if (!toast) return;
    toast.classList.remove("show");
  }

  function postRefresh(nonce){
    var msg = { type: "FA_REFRESH", nonce: nonce };
    try { window.top.postMessage(msg, "*"); } catch(e){}
    try {
      if (window.parent && window.parent !== window) window.parent.postMessage(msg, "*");
    } catch(e){}
  }

  function hardReloadSelf(){
    try {
      var u = new URL(location.href);
      u.searchParams.set("r", String(Date.now()));
      u.searchParams.set("fresh", "1");
      location.replace(u.toString());
    } catch(e) {
      location.reload();
    }
  }

  function requestRefresh(){
    var nonce = Date.now();
    var didUnload = false;
    window.addEventListener("beforeunload", function(){ didUnload = true; }, { once:true });

    if (isEmbedded()) postRefresh(nonce);
    else hardReloadSelf();

    setTimeout(function(){
      if (!didUnload) hardReloadSelf();
    }, 350);
  }

  var startY = 0, startX = 0, lastDy = 0;
  var armed = false;

  // Make accidental refreshes harder, but still easy enough when intentional
  var THRESH = 120;   // was 90
  var SHOW_AT = 18;   // was 12
  var MAX_SLOP_X = 80;
  var VERTICAL_RATIO = 2.0;

  window.addEventListener("touchstart", function(e){
    if (!e.touches || e.touches.length !== 1) { armed = false; return; }

    // Only arm when the MAIN page is truly at the top
    if (scrollTop() > 0) { armed = false; return; }

    // Never arm while a modal/overlay is open (prevents modal-top bounce triggering refresh)
    if (isModalOpen() || inModalOrOverlay(e.target)) { armed = false; return; }

    // Never arm on buttons/inputs/explicit no-ptr zones
    if (isInteractiveTarget(e.target)) { armed = false; return; }

    var t = e.touches[0];
    startY = t.clientY;
    startX = t.clientX;
    lastDy = 0;

    // Allow pull-to-refresh starting anywhere below the sticky header
    armed = (startY >= (headerBottom() + 6));
  }, { passive:true });

  window.addEventListener("touchmove", function(e){
    if (!armed || !e.touches || e.touches.length !== 1) return;

    var t = e.touches[0];
    var dy = t.clientY - startY;
    var dx = t.clientX - startX;

    if (dy <= 0){
      lastDy = 0;
      hideToast();
      return;
    }

    var adx = Math.abs(dx);
    if (adx > MAX_SLOP_X || dy < adx * VERTICAL_RATIO){
      lastDy = 0;
      hideToast();
      return;
    }

    if (dy > SHOW_AT){
      lastDy = dy;
      showToast();
    }
  }, { passive:true });

  window.addEventListener("touchend", function(){
    if (!armed){ hideToast(); return; }

    if (lastDy >= THRESH){
      showToast();
      setTimeout(requestRefresh, 60);
    } else {
      hideToast();
    }

    armed = false;
    lastDy = 0;
  }, { passive:true });

  window.addEventListener("touchcancel", function(){
    armed = false;
    lastDy = 0;
    hideToast();
  }, { passive:true });
})();
</script>
<script>
(function(){
  try{
    var path = (window.location.pathname || "").toLowerCase();
    var file = path.split("/").pop() || "";
    var page = "";
    if (file.endsWith(".html")) page = file.slice(0, -5);
    if (!page){
      // if served as /page (without .html), try first segment
      var seg = path.split("/").filter(Boolean)[0] || "";
      page = seg;
    }
    if (page && window.faSetActiveByPage) window.faSetActiveByPage(page);
  }catch(_){}
})();
</script>



<script>
/* =========================
   google.script.run → fetch() bridge (Native Fetch Polyfill)
   - Set window.GAS_API_URL once (or edit the hardcoded GAS_API_URL fallback)
   ========================= */
(function(){
  const GAS_API_URL = window.GAS_API_URL || "https://script.google.com/macros/s/AKfycbxlyif58qdt0l90lSvHOm0TxlPffdfMqajwzhGDQlddsNNn82Bg37CGoMpjBKBuZoNK/exec";
  window.GAS_API_URL = GAS_API_URL;

  function createProxy(s, f){
    return new Proxy({}, {
      get: (t, prop) => {
        if (prop === 'withSuccessHandler') return (cb) => createProxy(cb, f);
        if (prop === 'withFailureHandler') return (cb) => createProxy(s, cb);
        return (...args) => fetch(GAS_API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=utf-8' },
          body: JSON.stringify({ action: prop, args: args })
        })
        .then(r => r.text()).then(t => { 
          if (!t) throw new Error("Empty response from GAS. Check FA_GAS_API_URL + deployment access.");
          try { return JSON.parse(t); } catch(e){ console.error("Non-JSON response:", t.slice(0,300)); throw e; }
        })
        .then(d => { if (d && d.ok && s) s(d.result); else if (d && d.ok === false && f) f(d); })
        .catch(e => { if (f) f(e); });
      }
    });
  }

  window.google = window.google || {};
  window.google.script = window.google.script || {};
  if (!window.google.script.run){
    window.google.script.run = new Proxy({}, { get: (t, prop) => createProxy(null, null)[prop] });
  }
})();
</script>

<div class="panel">
  <div class="panel-titlebar">STANDINGS</div>

  <div class="table-wrap" style="margin-top:10px;">
    <table>
      <colgroup>
        <col style="width:38%;">
        <col style="width:7%;">
        <col style="width:7%;">
        <col style="width:16%;">
        <col style="width:16%;">
        <col style="width:16%;">
      </colgroup>
      <thead>
        <tr>
          <th style="text-align:left;">TEAM</th>
          <th>W</th>
          <th>L</th>
          <th>PS</th>
          <th>PA</th>
          <th>%</th>
        </tr>
      </thead>
      <tbody id="body">
        <tr><td colspan="6" class="small" style="padding:14px;">Loading…</td></tr>
      </tbody>
    </table>
  
  <div id="meta" class="small" style="margin-top:10px;"></div>
</div>
</div>




<details class="panel collapsible" id="matchResults">
  <summary>MATCH RESULTS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div id="results"></div>


  </div>
</details>

<details class="panel collapsible" id="bigUpsets">
  <summary>BIGGEST UPSETS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div id="upsets"></div>
  </div>
</details>

<details class="panel collapsible" id="simMatchup">
  <summary>SIMULATE MATCHUP<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">
    <div class="adj-grid">
      <div><select id="simTeamA" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select>
      </div>
      <div><select id="simTeamB" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select>
      </div>
    </div>
<div id="simOut" style="margin-top:10px;"></div>
  </div>
</details>

<details class="panel collapsible" id="adjWrap">
  <summary>PENALTY POINTS<span class="collap-chevron">▾</span></summary>
  <div class="collap-body">

        
    <div style="margin-top:10px; border-top:1px solid #eef2f7; padding-top:10px;">
            <div class="adj-grid">
        <div><div class="small">Date</div><input id="adjDate" type="date" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900;"></div>
        <div><div class="small">Add penalty points</div><select id="adjTeam" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select></div>
        <div><div class="small">Opponent team</div><select id="adjOpp" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900; background:#fff;"></select></div>
        <div><div class="small">Penalty Points</div><input id="adjDelta" placeholder="4" inputmode="decimal" style="width:100%; padding:10px 10px; border:1px solid #e6edf5; border-radius:12px; font-weight:900;"></div>
      </div>      <div style="display:flex; gap:10px; margin-top:10px; align-items:center; flex-wrap:wrap;">
        <button id="adjSave" style="border:0; border-radius:14px; padding:10px 14px; font-weight:1000; color:#fff; background:linear-gradient(var(--btn-angle), #ff3b3b, #e40000);">SAVE</button>        <div class="small" id="adjMsg"></div>
      </div>
      <div style="margin-top:12px; border-top:1px solid #eef2f7; padding-top:12px;">
        <div id="adjList" class="small" style="padding:6px 2px;"></div>
      </div>

    </div>
  
  </div>
</details>


<!-- Match details modal (tap a Match Result card) -->
<div class="modal" id="matchDetailsModal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="mdTitle">
    <div class="modal-head">
      <div class="title" id="mdTitle">MATCH DETAILS</div>
      <button class="icon-btn" id="mdCloseBtn" type="button" aria-label="Close"><span>×</span></button>
    </div>
    <div class="modal-body" id="mdBody">
      <div class="modal-meta">
        <div class="field">
          <div class="label">Home Team</div>
          <select id="mdLoc"></select>
        </div>
      </div>
      <div id="mdCards"></div>
    </div>
  </div>
</div>

<script>
const $ = (id)=>document.getElementById(id);
function esc(s){ return (s==null?"":String(s)).replace(/[&<>"]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c])); }
function dispTeamName(s){ return String(s||"").replace(/^OPP\s*-\s*/i,"").trim(); }
function normTeam(s){
  return dispTeamName(s)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g," ")
    .replace(/\s+/g," ")
    .trim();
}

/* =========================
   Server bridge: runGs()
   - Apps Script: google.script.run
   - Static hosting fallback: window.GAS_API_URL (exec endpoint)
   ========================= */
async function runGs(fn, args){
  // Apps Script HTML service
  if (window.google && google.script && google.script.run){
    return await new Promise((resolve, reject)=>{
      try{
        let r = google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(err=>{
            try{
              const msg = (err && (err.message || err.toString())) ? (err.message || err.toString()) : String(err||"Server error");
              reject(new Error(msg));
            }catch(_e){ reject(err); }
          });

        if (Array.isArray(args)) r[fn].apply(r, args);
        else if (args == null) r[fn]();
        else r[fn](args);
      }catch(e){ reject(e); }
    });
  }

  // Static hosting fallback
  const url = window.GAS_API_URL;
  if (!url) throw new Error("runGs is not available (missing google.script.run and window.GAS_API_URL). ");

  const bodyArgs = Array.isArray(args) ? args : (args == null ? [] : [args]);
  const resp = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "text/plain;charset=utf-8" },
    body: JSON.stringify({ action: fn, args: bodyArgs })
  });

  const t = await resp.text();
  if (!t) throw new Error("Empty response from GAS.");

  let data;
  try{ data = JSON.parse(t); }catch(e){ console.error("Non-JSON response:", t.slice(0,300)); throw e; }

  if (data && typeof data === "object"){
    if (data.ok === false) throw new Error(data.error || data.message || "Server error");
    if (Object.prototype.hasOwnProperty.call(data, "result")) return data.result;
  }
  return data;
}

function pointsForMode(mode){
  mode = String(mode||"").toLowerCase().trim();
  if (mode === "singles") return 1;
  if (mode === "doubles") return 2;
  if (mode === "triples") return 3;
  return 0;
}
function pointsSplit(mode){
  const p = pointsForMode(mode);
  return p ? (p/2) : 0;
}
function fmtPts(x){
  const n = Number(x||0);
  if (!isFinite(n)) return "0";
  const v = Math.round(n*10)/10; // keep at 1 decimal max
  // strip trailing .0
  if (Math.abs(v - Math.round(v)) < 1e-9) return String(Math.round(v));
  let s = v.toFixed(1);
  if (s.endsWith(".0")) s = s.slice(0,-2);
  return s;
}

function parseDateKey(ts){
  const s = String(ts||"").trim();
  if (!s) return "";

  // mm/dd/yyyy or m/d/yyyy
  let m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
  if (m){
    const mm = m[1].padStart(2,"0");
    const dd = m[2].padStart(2,"0");
    const yy = m[3];
    return `${yy}-${mm}-${dd}`;
  }

  // mm/dd/yy or m/d/yy
  m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})/);
  if (m){
    const mm = m[1].padStart(2,"0");
    const dd = m[2].padStart(2,"0");
    const y2 = Number(m[3]);
    const yy = (y2 <= 79) ? (2000 + y2) : (1900 + y2);
    return `${yy}-${mm}-${dd}`;
  }

  // yyyy-mm-dd
  const m2 = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (m2) return `${m2[1]}-${m2[2]}-${m2[3]}`;

  const d = new Date(s);
  if (!isNaN(d.getTime())){
    const yy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  return "";
}
function fmtDateShort(dk){
  const m = String(dk||"").match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return dk || "";
  const yy = m[1].slice(2);
  return `${Number(m[2])}/${Number(m[3])}/${yy}`;
}
function pickOrder(team1, team2){
  // Return [left, right] by preference:
  // - If one is Flying Aces, keep it on the RIGHT (matches your example).
  // - Otherwise alphabetical.
  const a = team1.name, b = team2.name;
  const aFA = /flying\s*aces/i.test(a);
  const bFA = /flying\s*aces/i.test(b);
  if (aFA && !bFA) return [team2.key, team1.key];
  if (bFA && !aFA) return [team1.key, team2.key];
  return (a.localeCompare(b) <= 0) ? [team1.key, team2.key] : [team2.key, team1.key];
}

function computeFromMatchLog(rows, adjustments){
  const teamTotals = new Map(); // teamKey -> {name, w,l,t, points, possible}
  const matchups = new Map();   // key = dateKey|sortedPair -> {dateKey, teams: Map(teamKey->{name,pts,possible})}

  // Build adjustment map: key = dateKey|sortedPair -> [{teamKey, delta}]
  const adjMap = new Map();
  for (const a of (adjustments||[])){
    const dk = parseDateKey(a.dateKey || a.dateDisp || "");
    const t1 = normTeam(a.team||"");
    const t2 = normTeam(a.opp||"");
    if (!dk || !t1 || !t2) continue;
    const pair = [t1,t2].sort().join("|");
    const key = dk + "|" + pair;
    if (!adjMap.has(key)) adjMap.set(key, []);
    adjMap.get(key).push({ teamKey: t1, delta: Number(a.delta||0) });
  }

  function ensureLeagueTeam(teamKey, teamName){
    if (!teamTotals.has(teamKey)){
      teamTotals.set(teamKey, { key:teamKey, team:teamName, w:0, l:0, t:0, points:0, pa:0, possible:0 });
    }
    return teamTotals.get(teamKey);
  }

  function ensureMatchup(dateKey, keyA, nameA, keyB, nameB){
    const pair = [keyA, keyB].sort().join("|");
    const k = (dateKey || "unknown") + "|" + pair;
    if (!matchups.has(k)){
      matchups.set(k, {
        dateKey: dateKey || "unknown",
        rows: [],
        teams: new Map([
          [keyA, { key:keyA, name:nameA, pts:0, possible:0 }],
          [keyB, { key:keyB, name:nameB, pts:0, possible:0 }]
        ])
      });
    } else {
      const g = matchups.get(k);
      if (!g.teams.has(keyA)) g.teams.set(keyA, { key:keyA, name:nameA, pts:0, possible:0 });
      if (!g.teams.has(keyB)) g.teams.set(keyB, { key:keyB, name:nameB, pts:0, possible:0 });
    }
    return matchups.get(k);
  }

  // 1) Accumulate MatchLog rows into matchup totals (points + possible)
  for (const r of (rows||[])){
    const teamAraw = r.teamA ?? r["Team A"] ?? r.team_a ?? "";
    const teamBraw = r.teamB ?? r["Team B"] ?? r.team_b ?? "";
    const mode = (r.mode ?? r.Mode ?? "").toString().toLowerCase().trim();
    const result = (r.result ?? r.Result ?? "").toString().toUpperCase().trim();
    const ts = r.timestamp ?? r.Timestamp ?? "";

    if (!teamAraw || !teamBraw) continue;

    const pWin = pointsForMode(mode);
    if (!pWin) continue;

    const dateKey = parseDateKey(ts);
    const nameA = dispTeamName(teamAraw);
    const nameB = dispTeamName(teamBraw);
    const keyA = normTeam(teamAraw);
    const keyB = normTeam(teamBraw);

    ensureLeagueTeam(keyA, nameA);
    ensureLeagueTeam(keyB, nameB);

    const g = ensureMatchup(dateKey, keyA, nameA, keyB, nameB);
    // Keep rows for Match Details modal
    try{ if (g && g.rows) g.rows.push(r); }catch(_){ }
    const A = g.teams.get(keyA);
    const B = g.teams.get(keyB);

    // possible points for this row
    A.possible += pWin;
    B.possible += pWin;

    // points earned for this row
    if (result === "W"){ A.pts += pWin; }
    else if (result === "L"){ B.pts += pWin; }
    else { const half = pointsSplit(mode); A.pts += half; B.pts += half; }
  }

  // 2) Convert matchups to list, apply adjustments, then compute W/L (1 per matchup) and league totals
  const matchupList = [];

  for (const [key, g] of matchups.entries()){
    const teamArr = Array.from(g.teams.values());
    if (teamArr.length < 2) continue;

    let [leftKey, rightKey] = pickOrder(teamArr[0], teamArr[1]);
    let L = g.teams.get(leftKey);
    let R = g.teams.get(rightKey);

    // Apply adjustments to pts AND possible (both teams possible increases by abs(delta))
    const adjList = adjMap.get(key) || [];
    let lAdj = 0, rAdj = 0, possAdj = 0;
    for (const ad of adjList){
      const d = Number(ad.delta||0);
      if (!isFinite(d) || !d) continue;
      possAdj += Math.abs(d);
      if (ad.teamKey === L.key) lAdj += d;
      else if (ad.teamKey === R.key) rAdj += d;
    }
    if (lAdj) L.pts += lAdj;
    if (rAdj) R.pts += rAdj;
    if (possAdj){
      L.possible += possAdj;
      R.possible += possAdj;
    }

    // Winner always on the LEFT (after adjustments)
    if (R.pts > L.pts){
      const tmp = L; L = R; R = tmp;
    } else if (R.pts === L.pts){
      // Tie: alphabetical by team name
      if (String(R.name).localeCompare(String(L.name)) < 0){
        const tmp = L; L = R; R = tmp;
      }
    }

    const LT = ensureLeagueTeam(L.key, L.name);
    const RT = ensureLeagueTeam(R.key, R.name);

    LT.points += L.pts; LT.pa += R.pts; LT.possible += L.possible;
    RT.points += R.pts; RT.pa += L.pts; RT.possible += R.possible;

    if (L.pts > R.pts){ LT.w++; RT.l++; }
    else if (R.pts > L.pts){ LT.l++; RT.w++; }
    else { LT.t++; RT.t++; }

    const cls = (L.pts > R.pts) ? "score-win" : (R.pts > L.pts) ? "score-loss" : "score-tie";

    matchupList.push({
      matchupKey: key,
      dateKey: g.dateKey,
      dateShort: fmtDateShort(g.dateKey),
      rows: (g.rows || []).slice(),
      leftTeam: L.name,
      rightTeam: R.name,
      leftPts: L.pts,
      rightPts: R.pts,
      cls
    });
  }

  const standings = Array.from(teamTotals.values()).map(s=>{
    const games = s.w + s.l + s.t;
    const winPct = games ? ((s.w + 0.5*s.t) / games) : 0;
    const pointsPct = s.possible ? (s.points / s.possible) : 0;
    return { team:s.team, key:s.key, w:s.w, l:s.l, t:s.t, points:s.points, pa:s.pa, possible:s.possible, winPct, pointsPct };
  });

  standings.sort((a,b)=>{
    if (b.winPct !== a.winPct) return b.winPct - a.winPct;
    if (b.pointsPct !== a.pointsPct) return b.pointsPct - a.pointsPct;
    if (b.points !== a.points) return b.points - a.points;
    return a.team.localeCompare(b.team);
  });

  // Oldest -> newest
  matchupList.sort((a,b)=>{
    const da = a.dateKey || "";
    const db = b.dateKey || "";
    if (da !== db) return da.localeCompare(db);
    const x = (a.leftTeam + " vs " + a.rightTeam);
    const y = (b.leftTeam + " vs " + b.rightTeam);
    return x.localeCompare(y);
  });

  const uniqueDates = new Set(matchupList.map(m=>m.dateKey)).size;
  return { standings, matchupList, matchupCount: matchupList.length, dateCount: uniqueDates };
}


function fillTeamDropdowns(standingsRows){
  const teamSel = $("adjTeam");
  const oppSel  = $("adjOpp");
  if (!teamSel || !oppSel) return;

  const teams = (standingsRows || []).map(r=>dispTeamName(r.team)).filter(Boolean);
  teams.sort((a,b)=>a.localeCompare(b));

  function setOptions(sel){
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Select team…";
    sel.appendChild(opt0);
    for (const t of teams){
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      sel.appendChild(o);
    }
  }
  setOptions(teamSel);
  setOptions(oppSel);

  // Prevent choosing same team for opp
  function enforce(){
    const tv = teamSel.value;
    Array.from(oppSel.options).forEach(o=>{
      o.disabled = (tv && o.value === tv);
    });
    if (oppSel.value === tv) oppSel.value = "";
  }
  teamSel.addEventListener("change", enforce);
  enforce();
}


// ----------------- Matchup simulator (team Elo win%) -----------------
let _teamEloMap = Object.create(null);
let _teamEloLoaded = false;
let _lastMatchups = [];

function isGas(){
  return (typeof google !== "undefined" && google.script && google.script.run);
}
function normTeam(s){
  return String(s||"").trim().toLowerCase();
}

function fillSimTeamSelects(standingsRows){
  const selA = $("simTeamA");
  const selB = $("simTeamB");
  if (!selA || !selB) return;

  const teams = (standingsRows||[]).map(r=>dispTeamName(r.team)).filter(Boolean);
  teams.sort((a,b)=>a.localeCompare(b));

  const prevA = selA.value || "";
  const prevB = selB.value || "";

  function setOptions(sel){
    sel.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "Select team…";
    sel.appendChild(o0);
    for (const t of teams){
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      sel.appendChild(o);
    }
  }
  setOptions(selA);
  setOptions(selB);

  // restore (if still available)
  selA.value = teams.includes(prevA) ? prevA : "";
  selB.value = teams.includes(prevB) ? prevB : "";

  function enforce(){
    const a = selA.value;
    Array.from(selB.options).forEach(o=>{ o.disabled = (a && o.value === a); });
    if (selB.value === a) selB.value = "";
    updateSimOut();
    if (_lastMatchups && _lastMatchups.length) renderUpsets(_lastMatchups);
  }
  selA.onchange = ()=>{ enforce(); };
  selB.onchange = ()=>{ updateSimOut(); };

  enforce();
}

function loadTeamEloAverages(){
  if (_teamEloLoaded) return;
  _teamEloLoaded = true;

  const out = $("simOut");
  if (out) out.innerHTML = `<div class="small">Loading team Elo…</div>`;

  if (!isGas()){
    if (out) out.innerHTML = `<div class="small">Team Elo unavailable (not running in Apps Script).</div>`;
    return;
  }

  runGs("faGetTeamEloAverages_v1", { includeInactive:false })
    .then(res=>{
      if (!res || res.ok === false){
        throw new Error(res && res.message ? res.message : "faGetTeamEloAverages_v1 failed");
      }
      const rows = res.rows || [];
      _teamEloMap = Object.create(null);
      rows.forEach(r=>{
        const t = String(r.team||"").trim();
        const e = Number(r.avgElo);
        if (!t || !isFinite(e)) return;
        _teamEloMap[normTeam(t)] = e;
      });
      updateSimOut();
    if (_lastMatchups && _lastMatchups.length) renderUpsets(_lastMatchups);
    })
    .catch(err=>{
      console.error(err);
      if (out) out.innerHTML = `<div class="small">Couldn’t load team Elo. Make sure PlayersDB has an <b>ELO</b> column.</div>`;
    });
}

function eloWinProb(eloA, eloB){
  // Elo logistic curve (125-point scale)
  const exp = (Number(eloB) - Number(eloA)) / 125;
  return 1 / (1 + Math.pow(10, exp));
}

function fmtPct(p){
  const n = Number(p);
  if (!isFinite(n)) return "—";
  return (Math.round(n*1000)/10).toFixed(1) + "%";
}
function fmtElo(n){
  n = Number(n);
  if (!isFinite(n)) return "—";
  return String(Math.round(n));
}

function updateSimOut(){
  const out = $("simOut");
  const selA = $("simTeamA");
  const selB = $("simTeamB");
  if (!out || !selA || !selB) return;

  const a = selA.value || "";
  const b = selB.value || "";
  if (!a || !b){
    out.innerHTML = `<div class="small">Pick two teams to see win percentages.</div>`;
    return;
  }

  if (!_teamEloLoaded || !_teamEloMap){
    out.innerHTML = `<div class="small">Loading team Elo…</div>`;
    return;
  }

  const eloA = _teamEloMap[normTeam(a)];
  const eloB = _teamEloMap[normTeam(b)];

  if (!isFinite(eloA) || !isFinite(eloB)){
    out.innerHTML = `<div class="small">Elo missing for one or both teams. (Check PlayersDB ELO values.)</div>`;
    return;
  }

  const pA = eloWinProb(eloA, eloB);
  const pB = 1 - pA;

  const hiStyle = `background:#ecfdf3; border-color:#bbf7d0; color:#15803d;`;
  const loStyle = `background:#fef2f2; border-color:#fecaca; color:#b91c1c;`;
  const tieStyle = `background:#f8fafc; border-color:#e2e8f0; color:#334155;`;

  const leftWinStyle  = (pA > pB) ? hiStyle : (pB > pA) ? loStyle : tieStyle;
  const rightWinStyle = (pB > pA) ? hiStyle : (pA > pB) ? loStyle : tieStyle;

  out.innerHTML = `
    <div class="match-card score-tie" style="grid-template-columns: 1fr 86px 1fr;">
      <div class="mc-left">
        <div class="mc-side-team">${esc(a)}</div>
        <div class="elo-pill">ELO ${esc(fmtElo(eloA))}</div>
        <div class="elo-pill" style="${leftWinStyle}">WIN ${esc(fmtPct(pA))}</div>
      </div>

      <div class="mc-mid">
        <div class="mc-score">VS</div>
      </div>

      <div class="mc-right">
        <div class="mc-side-team">${esc(b)}</div>
        <div class="elo-pill">ELO ${esc(fmtElo(eloB))}</div>
        <div class="elo-pill" style="${rightWinStyle}">WIN ${esc(fmtPct(pB))}</div>
      </div>
    </div>
  `;
}

function initSimulator(standingsRows){
  fillSimTeamSelects(standingsRows);
  loadTeamEloAverages();
  updateSimOut();
}
// -------------------------------------------------------------------

function renderStandings(rows, matchupCount){

  const tb = $("body");
  tb.innerHTML = "";

  if (!rows.length){
    tb.innerHTML = "<tr><td colspan='6' class='small' style='padding:14px;'>No league matches yet.</td></tr>";
    return;
  }

  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const pp = (r.pointsPct==null) ? "" : (Math.round(Number(r.pointsPct)*10000)/100).toFixed(2)+"%";
    tr.innerHTML =
      "<td style='font-weight:950; text-align:left;'>" + esc(dispTeamName(r.team)) + "</td>" +
      "<td>" + Number(r.w||0) + "</td>" +
      "<td>" + Number(r.l||0) + "</td>" +
      "<td>" + esc(fmtPts(r.ps)) + "</td>" +
      "<td>" + esc(fmtPts(r.pa)) + "</td>" +
      "<td style='font-weight:950;'><span class='pill'>" + pp + "</span></td>";
    tb.appendChild(tr);
  });
}



/* =========================
   Match Results: month grouping + match details modal + home/neutral meta
   ========================= */
/* =========================
   Match Results: month grouping + match details modal + home/neutral meta (LEAGUE-WIDE)
   - Stored server-side via StatsServer.gs:
     • faGetMatchMeta_v1()
     • faSetMatchMeta_v1(matchdayKey, meta)
   ========================= */

function _keyStr_(s){ return String(s||"").trim().toLowerCase(); }

let _matchMetaMap = {};      // matchupKey -> { mode:"neutral"|"home", homeTeam?:string }
let _matchMetaLoaded = false;

function _normClientMeta_(m){
  if (!m) return null;
  const mode = String(m.mode||"unspecified").toLowerCase();
  if (mode === "neutral") return { mode:"neutral" };
  if (mode === "home"){
    const ht = String(m.homeTeam||"").trim();
    return ht ? { mode:"home", homeTeam: ht } : null;
  }
  return null;
}

function _normMetaFromServer_(srv){
  if (!srv) return null;
  const site = String(srv.site || srv.mode || "unspecified").trim().toLowerCase();
  if (site === "neutral") return { mode:"neutral" };
  if (site === "home"){
    const ht = String(srv.homeTeam || srv.home || "").trim();
    return ht ? { mode:"home", homeTeam: ht } : null;
  }
  return null;
}

function _setMatchMetaMapFromServer_(metaMap){
  _matchMetaMap = {};
  if (!metaMap || typeof metaMap !== "object") return;
  for (const k in metaMap){
    const m = _normMetaFromServer_(metaMap[k]);
    if (m) _matchMetaMap[String(k)] = m;
  }
}

function getMatchMeta(matchupKey){
  const k = String(matchupKey||"");
  if (!k) return null;
  return _matchMetaMap[k] || null;
}

/** Load league-wide meta from server (called during load()). */
async function refreshMatchMetaFromServer(){
  try{
    const res = await runGs("faGetMatchMeta_v1", {});
    if (res && res.ok && res.meta) _setMatchMetaMapFromServer_(res.meta);
    _matchMetaLoaded = true;
  }catch(e){
    console.warn("MatchMeta load failed:", e);
    _matchMetaLoaded = true;
  }
}

/** Save league-wide meta to server (optimistic update). */
async function setMatchMeta(matchupKey, meta){
  const k = String(matchupKey||"");
  if (!k) return;

  const desired = _normClientMeta_(meta);
  const prev = _matchMetaMap[k] || null;

  // optimistic update in UI memory
  if (!desired) delete _matchMetaMap[k];
  else _matchMetaMap[k] = desired;

  const payload = (!desired)
    ? { site:"unspecified" }
    : (desired.mode === "neutral")
      ? { site:"neutral" }
      : { site:"home", homeTeam: String(desired.homeTeam) };

  try{
    const out = await runGs("faSetMatchMeta_v1", [k, payload]);
    if (out && out.ok === false){
      // revert on server validation failure
      if (prev) _matchMetaMap[k] = prev; else delete _matchMetaMap[k];
      console.warn(out.error || "MatchMeta save failed.");
    }
  }catch(e){
    if (prev) _matchMetaMap[k] = prev; else delete _matchMetaMap[k];
    console.warn("MatchMeta save failed:", e);
  }
}

function monthNameFromDateKey(dateKey){
  const dk = String(dateKey||"").trim();
  const m = (dk && dk.length >= 7) ? Number(dk.slice(5,7)) : NaN;
  const names = ["January","February","March","April","May","June","July","August","September","October","November","December"];
  if (!isFinite(m) || m < 1 || m > 12) return "";
  return names[m-1];
}

// Season-first ordering: Oct -> Mar (then everything else), plus Neutral at end.
const _MONTH_ORDER_ = ["October","November","December","January","February","March"];

function _groupKeyForMatch_(m){
  const meta = getMatchMeta(m.matchupKey);
  if (meta && meta.mode === "neutral") return "Neutral";
  const mn = monthNameFromDateKey(m.dateKey);
  return mn || "Other";
}

function _applyMetaToMatchup_(m){
  // Start with computed order (winner-left)
  let leftTeam = String(m.leftTeam||"");
  let rightTeam = String(m.rightTeam||"");
  let leftPts = Number(m.leftPts||0);
  let rightPts = Number(m.rightPts||0);

  const meta = getMatchMeta(m.matchupKey) || { mode:"unspecified", homeTeam:"" };
  const homeTeam = String(meta.homeTeam||"").trim();
  const mode = String(meta.mode||"unspecified");

  // Home team should be on the RIGHT when set
  if (mode === "home" && homeTeam){
    const hk = _keyStr_(homeTeam);
    if (hk === _keyStr_(leftTeam)){
      // swap to put home on right
      const t = leftTeam; leftTeam = rightTeam; rightTeam = t;
      const p = leftPts;  leftPts  = rightPts;  rightPts  = p;
    }
  }

  const cls = (leftPts > rightPts) ? "score-win" : (rightPts > leftPts) ? "score-loss" : "score-tie";
  return { leftTeam, rightTeam, leftPts, rightPts, cls, meta };
}

function _sortMatchRowsForModal_(rows){
  function isStrokeRow(r){
    const mode = String(r.mode ?? r.Mode ?? "").toLowerCase();
    const sm = String(r.scoreMode ?? r.ScoreMode ?? r.scoring ?? r.score_mode ?? "").toLowerCase();
    if (mode.includes("stroke")) return true;
    if (sm === "stroke") return true;
    // if numeric stroke scores exist, assume stroke
    const a = r.teamAScore ?? r.acesScore ?? r.scoreA ?? r.strokeA ?? r.aScore ?? r.AScore;
    const b = r.teamBScore ?? r.oppScore  ?? r.scoreB ?? r.strokeB ?? r.bScore ?? r.BScore;
    if (a != null && b != null && String(a).trim() !== "" && String(b).trim() !== "") return true;
    return false;
  }
  function cat(r){
    const mode = String(r.mode ?? r.Mode ?? "").toLowerCase();
    const stroke = isStrokeRow(r);
    const isD = mode.includes("double") || mode.includes("triple");
    const isS = mode.includes("single") || mode === "s";
    // Order requested: singles (match play) -> doubles -> singles (stroke) last
    if (isS && !stroke) return 0;
    if (isD) return 1;
    if (isS && stroke) return 2;
    // fallback
    return isD ? 1 : (stroke ? 2 : 0);
  }
  function ord(r){
    // keep stable-ish order if rowNum exists
    const n = Number(r.rowNum ?? r.row ?? r.Row ?? r._row ?? NaN);
    return isFinite(n) ? n : 1e18;
  }
  return (rows||[]).slice().sort((a,b)=>{
    const ca = cat(a), cb = cat(b);
    if (ca !== cb) return ca - cb;
    const oa = ord(a), ob = ord(b);
    if (oa !== ob) return oa - ob;
    return 0;
  });
}

function _pickFirst_(r, keys){
  for (const k of keys){
    const v = r[k];
    if (v == null) continue;
    const s = String(v).trim();
    if (s) return s;
  }
  return "";
}

function _buildPlayers_(r, side){
  // side "A" or "B"
  const isA = (side === "A");

  const A1 = ["a1","A1","teamA1","TeamA1","playerA1","PlayerA1","aces 1","Aces 1","aces1","Aces1","team a player 1","Team A Player 1","teamAPlayer1"];
  const A2 = ["a2","A2","teamA2","TeamA2","playerA2","PlayerA2","aces 2","Aces 2","aces2","Aces2","team a player 2","Team A Player 2","teamAPlayer2"];
  const A3 = ["a3","A3","teamA3","TeamA3","playerA3","PlayerA3","aces 3","Aces 3","aces3","Aces3","team a player 3","Team A Player 3","teamAPlayer3"];

  const B1 = ["b1","B1","o1","O1","teamB1","TeamB1","playerB1","PlayerB1","opp 1","Opp 1","opp1","Opp1","team b player 1","Team B Player 1","teamBPlayer1"];
  const B2 = ["b2","B2","o2","O2","teamB2","TeamB2","playerB2","PlayerB2","opp 2","Opp 2","opp2","Opp2","team b player 2","Team B Player 2","teamBPlayer2"];
  const B3 = ["b3","B3","o3","O3","teamB3","TeamB3","playerB3","PlayerB3","opp 3","Opp 3","opp3","Opp3","team b player 3","Team B Player 3","teamBPlayer3"];

  const p1 = _pickFirst_(r, isA ? A1 : B1);
  const p2 = _pickFirst_(r, isA ? A2 : B2);
  const p3 = _pickFirst_(r, isA ? A3 : B3);
  return [p1,p2,p3].filter(Boolean);
}

function _invertResult_(res){
  res = String(res||"").toUpperCase().trim();
  if (res === "W") return "L";
  if (res === "L") return "W";
  return "T";
}

function _isStrokeRow_(r){
  const mode = String(r.mode ?? r.Mode ?? "").toLowerCase();
  const sm = String(r.scoreMode ?? r.ScoreMode ?? r.scoring ?? r.score_mode ?? "").toLowerCase();
  if (mode.includes("stroke")) return true;
  if (sm === "stroke") return true;
  const a = _pickFirst_(r, ["teamAScore","acesScore","scoreA","strokeA","aScore","AScore"]);
  const b = _pickFirst_(r, ["teamBScore","oppScore","scoreB","strokeB","bScore","BScore"]);
  return !!(a && b);
}

function _scoreText_(r, swapped){
  const isStroke = _isStrokeRow_(r);
  if (!isStroke){
    const mp = _pickFirst_(r, ["mpScore","MPScore","score","Score","matchScore","MatchScore"]);
    return mp || "—";
  }
  let a = _pickFirst_(r, ["teamAScore","acesScore","scoreA","strokeA","aScore","AScore"]);
  let b = _pickFirst_(r, ["teamBScore","oppScore","scoreB","strokeB","bScore","BScore"]);
  if (swapped){ const t=a; a=b; b=t; }
  if (!a && !b) return "—";
  return (a||"") + "–" + (b||"");
}

function _modeLabel_(r){
  const mode = String(r.mode ?? r.Mode ?? "").toLowerCase();
  const stroke = _isStrokeRow_(r);
  if (mode.includes("double")) return "DOUBLES";
  if (mode.includes("triple")) return "TRIPLES";
  if (mode.includes("single")) return stroke ? "SINGLES • STROKE" : "SINGLES";
  return stroke ? "STROKE" : "MATCH";
}


function _matchplayText_(row, resLeft){
  const mp = _pickFirst_(row, ["mpScore","MPScore","matchScore","MatchScore","score","Score","aScore","AScore","acesScore"]);
  const s = String(mp||"").trim();
  if (s) return s;
  if (resLeft === "T") return "PUSH";
  return resLeft || "—";
}

function _calcTotals_(rows, disp){
  const tieShare = 0.5;
  let sL=0, sR=0, dL=0, dR=0;
  for (const r0 of (rows||[])){
    const row = r0 || {};
    const mode = String(row.mode ?? row.Mode ?? "").toLowerCase();
    const isStroke = _isStrokeRow_(row);
    const isD = mode.includes("double") || mode.includes("triple");
    const isS = mode.includes("single") || mode === "s";

    const p = pointsForMode(mode);

    // Align row with displayed left/right
    const rowTeamA = String(row.teamA ?? row["Team A"] ?? row.team_a ?? "").trim() || _pickFirst_(row, ["teamAName","TeamAName"]);
    const rowTeamB = String(row.teamB ?? row["Team B"] ?? row.team_b ?? "").trim() || _pickFirst_(row, ["teamBName","TeamBName"]);
    let swapped = false;
    if (_keyStr_(rowTeamA) === _keyStr_(disp.rightTeam) && _keyStr_(rowTeamB) === _keyStr_(disp.leftTeam)) swapped = true;

    const resA = String(row.result ?? row.Result ?? "").toUpperCase().trim();
    const resLeft = swapped ? _invertResult_(resA) : resA;

    const add = (bucket)=>{
      if (resLeft === "W") { bucket.L += p; }
      else if (resLeft === "L") { bucket.R += p; }
      else { bucket.L += p * tieShare; bucket.R += p * tieShare; }
    };

    if (isS && !isStroke){
      const b = {L:0,R:0}; add(b); sL += b.L; sR += b.R;
    } else if (isD || (isS && isStroke)){
      const b = {L:0,R:0}; add(b); dL += b.L; dR += b.R;
    }
  }
  return { singles:{L:sL,R:sR}, doubles:{L:dL,R:dR} };
}

function _summaryCardHtml_(label, leftVal, rightVal){
  return `
    <div class="match-card score-tie" style="border-style:dashed; opacity:.95;">
      <div class="mc-left" style="display:flex; justify-content:center;">
        <div class="mc-player"><div class="mc-player-name" style="width:100%; text-align:center;">${esc(fmtPts(leftVal))}</div></div>
      </div>
      <div class="mc-mid">
        <div class="mc-score" style="font-size:11px; font-weight:950; letter-spacing:.06em;">${esc(label)}</div>
      </div>
      <div class="mc-right" style="display:flex; justify-content:center;">
        <div class="mc-player right"><div class="mc-player-name" style="width:100%; text-align:center;">${esc(fmtPts(rightVal))}</div></div>
      </div>
    </div>
  `;
}

function _renderMatchDetailsCards_(m, disp, rows){
  const cardsEl = $("mdCards");
  if (!cardsEl) return;

  const sorted = _sortMatchRowsForModal_(rows || []);
  const singlesMP = [];
  const doubles = [];
  for (const r of sorted){
    const mode = String(r.mode ?? r.Mode ?? "").toLowerCase();
    const isStroke = _isStrokeRow_(r);
    const isD = mode.includes("double") || mode.includes("triple");
    const isS = mode.includes("single") || mode === "s";
    if (isS && !isStroke) singlesMP.push(r);
    else if (isD || (isS && isStroke)) doubles.push(r);
  }

  const totals = _calcTotals_(sorted, disp);

  let html = "<div style='display:grid; gap:10px;'>";

    function rowCard(row){
    const rowTeamA = String(row.teamA ?? row["Team A"] ?? row.team_a ?? "").trim() || _pickFirst_(row, ["teamAName","TeamAName"]);
    const rowTeamB = String(row.teamB ?? row["Team B"] ?? row.team_b ?? "").trim() || _pickFirst_(row, ["teamBName","TeamBName"]);

    let swapped = false;
    if (_keyStr_(rowTeamA) === _keyStr_(disp.rightTeam) && _keyStr_(rowTeamB) === _keyStr_(disp.leftTeam)) swapped = true;

    const leftPlayers  = swapped ? _buildPlayers_(row, "B") : _buildPlayers_(row, "A");
    const rightPlayers = swapped ? _buildPlayers_(row, "A") : _buildPlayers_(row, "B");

    const resA = String(row.result ?? row.Result ?? "").toUpperCase().trim();
    const resLeft = swapped ? _invertResult_(resA) : resA;
    const cls = (resLeft === "W") ? "score-win" : (resLeft === "L") ? "score-loss" : "score-tie";

    const playersCell = (players, alignRight)=>{
      if (!players || !players.length){
        return `<div class="mc-player${alignRight ? " right" : ""}"><div class="mc-player-name">—</div></div>`;
      }
      if (players.length === 1){
        return `<div class="mc-player${alignRight ? " right" : ""}"><div class="mc-player-name">${esc(players[0])}</div></div>`;
      }
      // stack (2v2 / 3v3)
      const lines = players.map(p=>`<div class="mc-player-line">${esc(p)}</div>`).join("");
      return `<div class="mc-player${alignRight ? " right" : ""}"><div class="mc-player-stack${alignRight ? " right" : ""}">${lines}</div></div>`;
    };

    const leftHtml  = playersCell(leftPlayers, false);
    const rightHtml = playersCell(rightPlayers, true);

    let scoreHtml = "";
    if (_isStrokeRow_(row)){
      let a = _pickFirst_(row, ["teamAScore","acesScore","scoreA","strokeA","aScore","AScore"]);
      let b = _pickFirst_(row, ["teamBScore","oppScore","scoreB","strokeB","bScore","BScore"]);
      if (swapped){ const t=a; a=b; b=t; }
      const scoreTxt = (String(a||"").trim() || String(b||"").trim()) ? ((a||"") + "–" + (b||"")) : "—";
      scoreHtml = `<div class="mc-score mc-score-stroke">${esc(scoreTxt)}</div>`;
    } else {
      const mpTxt = _matchplayText_(row, resLeft);
      scoreHtml = `<div class="mc-score">${esc(mpTxt)}</div>`;
    }

    return `
      <div class="match-card ${cls}">
        <div class="mc-left">${leftHtml}</div>
        <div class="mc-mid">${scoreHtml}</div>
        <div class="mc-right">${rightHtml}</div>
      </div>
    `;
  }  }

  for (const r of singlesMP) html += rowCard(r);
  if (singlesMP.length){
    html += _summaryCardHtml_("SINGLES TOTAL", totals.singles.L, totals.singles.R);
  }

  for (const r of doubles) html += rowCard(r);
  if (doubles.length){
    html += _summaryCardHtml_("DOUBLES TOTAL", totals.doubles.L, totals.doubles.R);
  }


  html += "</div>";
  cardsEl.innerHTML = html;
}

async function openMatchDetailsModal(m){
  if (!m) return;
  const modal = $("matchDetailsModal");
  if (!modal) return;

  const titleEl = $("mdTitle");
  const cardsEl = $("mdCards");
  const locSel = $("mdLoc");

  const disp = _applyMetaToMatchup_(m);
  const dateLbl = String(m.dateShort || fmtDateShort(String(m.dateKey||"")) || m.dateKey || "").trim();

  if (titleEl){
    titleEl.textContent =
      (dateLbl ? (dateLbl + " • ") : "") +
      disp.leftTeam + " vs " + disp.rightTeam + " • " +
      fmtPts(disp.leftPts) + "–" + fmtPts(disp.rightPts);
  }

  // Home Team select (league-wide)
  if (locSel){
    locSel.innerHTML = "";

    const opt0 = document.createElement("option");
    opt0.value = "unspecified";
    opt0.textContent = "Unspecified";
    locSel.appendChild(opt0);

    const optN = document.createElement("option");
    optN.value = "neutral";
    optN.textContent = "Neutral";
    locSel.appendChild(optN);

    const optHR = document.createElement("option");
    optHR.value = "home:" + disp.rightTeam;
    optHR.textContent = disp.rightTeam;
    locSel.appendChild(optHR);

    const optHL = document.createElement("option");
    optHL.value = "home:" + disp.leftTeam;
    optHL.textContent = disp.leftTeam;
    locSel.appendChild(optHL);

    const curMeta = getMatchMeta(m.matchupKey);
    if (!curMeta) locSel.value = "unspecified";
    else if (curMeta.mode === "neutral") locSel.value = "neutral";
    else if (curMeta.mode === "home" && curMeta.homeTeam){
      locSel.value = "home:" + String(curMeta.homeTeam);
      if (!Array.from(locSel.options).some(o=>o.value === locSel.value)) locSel.value = "unspecified";
    } else locSel.value = "unspecified";

    locSel.onchange = async ()=>{
      const v = String(locSel.value||"");
      if (v === "unspecified"){
        await setMatchMeta(m.matchupKey, { mode:"unspecified" });
      } else if (v === "neutral"){
        await setMatchMeta(m.matchupKey, { mode:"neutral" });
      } else if (v.startsWith("home:")){
        const homeTeam = v.slice(5);
        await setMatchMeta(m.matchupKey, { mode:"home", homeTeam });
      }
      try{ renderMatchups(_lastMatchups || []); }catch(_){}
      // Update title + cards with new ordering, without refetching match rows
      try{
        const disp2 = _applyMetaToMatchup_(m);
        if (titleEl){
          titleEl.textContent =
            (dateLbl ? (dateLbl + " • ") : "") +
            disp2.leftTeam + " vs " + disp2.rightTeam + " • " +
            fmtPts(disp2.leftPts) + "–" + fmtPts(disp2.rightPts);
        }
        if (m._rowsCache) _renderMatchDetailsCards_(m, disp2, m._rowsCache);
      }catch(_){}
    };
  }

  // Show modal immediately (so it feels instant)
  modal.classList.add("show");
  modal.setAttribute("aria-hidden","false");
  try{ document.body.classList.add("modal-open"); }catch(_){}

  // Load rows if needed
  if (!m._rowsCache){
    if (cardsEl) cardsEl.innerHTML = "<div class='small' style='padding:8px 2px;'>Loading match details…</div>";
    try{
      const res = await runGs("faGetMatchdayRows_v1", [String(m.matchupKey||"")]);
      const rows = (res && res.ok) ? (res.rows || []) : (res && res.rows ? res.rows : []);
      m._rowsCache = rows;
    }catch(e){
      if (cardsEl) cardsEl.innerHTML = "<div class='small' style='padding:8px 2px;'>Couldn’t load match details.</div>";
      return;
    }
  }

  _renderMatchDetailsCards_(m, _applyMetaToMatchup_(m), m._rowsCache || []);
}


function closeMatchDetailsModal(){
  const modal = $("matchDetailsModal");
  if (!modal) return;
  modal.classList.remove("show");
  modal.setAttribute("aria-hidden","true");
  try{ document.body.classList.remove("modal-open"); }catch(_){}
}

// Global close wiring (delegated so modal can be inserted anywhere)
document.addEventListener("click", (e)=>{
  const closeBtn = e.target && (e.target.id === "mdCloseBtn" || (e.target.closest && e.target.closest("#mdCloseBtn")));
  if (closeBtn){
    e.preventDefault();
    closeMatchDetailsModal();
    return;
  }
  const mm = $("matchDetailsModal");
  if (mm && mm.classList.contains("show") && e.target === mm){
    closeMatchDetailsModal();
  }
});
document.addEventListener("keydown", (e)=>{
  if (e.key === "Escape"){
    const mm = $("matchDetailsModal");
    if (mm && mm.classList.contains("show")) closeMatchDetailsModal();
  }
});

function renderMatchups(matchups){
  const root = $("results");
  if (!root) return;
  root.innerHTML = "";

  if (!matchups || !matchups.length){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>No matchups found in MatchLog.</div>";
    return;
  }

  // Build grouped structure
  const groups = new Map(); // label -> array
  for (const m0 of matchups){
    const m = m0 || {};
    const gk = _groupKeyForMatch_(m);
    if (!groups.has(gk)) groups.set(gk, []);
    groups.get(gk).push(m);
  }

  function groupSortKey(label){
    if (label === "Neutral") return 1000;
    if (label === "Other") return 900;
    const idx = _MONTH_ORDER_.indexOf(label);
    if (idx !== -1) return idx;
    // fallback: alphabetical
    return 500 + label.charCodeAt(0);
  }

  const orderedLabels = Array.from(groups.keys()).sort((a,b)=>{
    const ka = groupSortKey(a), kb = groupSortKey(b);
    if (ka !== kb) return ka - kb;
    return String(a).localeCompare(String(b));
  });

  for (const label of orderedLabels){
    const arr = (groups.get(label) || []).slice();
    // oldest -> newest within group
    arr.sort((a,b)=>{
      const da = String(a.dateKey||"");
      const db = String(b.dateKey||"");
      if (da !== db) return da.localeCompare(db);
      const x = String(a.leftTeam||"") + " vs " + String(a.rightTeam||"");
      const y = String(b.leftTeam||"") + " vs " + String(b.rightTeam||"");
      return x.localeCompare(y);
    });

    const sec = document.createElement("div");
    sec.className = "month-section";

    const h = document.createElement("div");
    h.className = "month-head";
    h.innerHTML = `<div>${esc(label)}</div>`;
    sec.appendChild(h);

    for (const m of arr){
      const disp = _applyMetaToMatchup_(m);

      const card = document.createElement("div");
      card.className = "match-card " + disp.cls;
      card.setAttribute("data-matchup-key", String(m.matchupKey||""));

      const leftCls  = (disp.leftPts > disp.rightPts) ? "score-win" : (disp.rightPts > disp.leftPts) ? "score-loss" : "score-tie";
      const rightCls = (disp.rightPts > disp.leftPts) ? "score-win" : (disp.leftPts > disp.rightPts) ? "score-loss" : "score-tie";

      card.innerHTML =
        "<div class='mc-left'>" +
          "<div class='mc-name'><span class='nm'>" + esc(disp.leftTeam) + "</span></div>" +
        "</div>" +

        "<div class='mc-mid'>" +
          "<div class='mc-date-pill'>" + esc(m.dateShort || m.dateKey || "") + "</div>" +
          "<div class='mc-score mc-score-stroke'>" +
            "<span class='" + leftCls + "'>" + esc(fmtPts(disp.leftPts)) + "</span>" +
            "<span style='opacity:.5;'>–</span>" +
            "<span class='" + rightCls + "'>" + esc(fmtPts(disp.rightPts)) + "</span>" +
          "</div>" +
        "</div>" +

        "<div class='mc-right'>" +
          "<div class='mc-name'><span class='nm'>" + esc(disp.rightTeam) + "</span></div>" +
        "</div>";

      card.addEventListener("click", ()=>{
        openMatchDetailsModal(m);
      });

      sec.appendChild(card);
    }

    root.appendChild(sec);
  }
}


function renderUpsets(upsets){
  const root = $("upsets");
  if (!root) return;

  if (!upsets || !upsets.length){
    root.innerHTML = "<div class='small' style='padding:8px 2px;'>No upsets found.</div>";
    return;
  }

  let html = "<div style='display:grid; gap:10px;'>";

  for (let i=0; i<upsets.length; i++){
    const u = upsets[i] || {};
    const rank = i + 1;

    const label = `#${rank} • WIN ${fmtPct(u.expected)}`;

    const leftTeam = String(u.winner || "");
    const rightTeam = String(u.loser || "");
    const leftPts = Number(u.winPts || 0);
    const rightPts = Number(u.losePts || 0);

    const leftCls = (leftPts > rightPts) ? "score-win" : (rightPts > leftPts) ? "score-loss" : "score-tie";
    const rightCls = (rightPts > leftPts) ? "score-win" : (leftPts > rightPts) ? "score-loss" : "score-tie";
    const cls = (leftPts > rightPts) ? "score-win" : (rightPts > leftPts) ? "score-loss" : "score-tie";

    // Find matchday record for modal (fallback is fine — modal fetches rows by matchupKey)
    const m = (_lastMatchups || []).find(x=>String(x.matchupKey||"") === String(u.matchupKey||"")) || {
      matchupKey: u.matchupKey,
      dateKey: u.dateKey,
      dateShort: u.dateKey ? fmtDateShort(String(u.dateKey)) : "",
      leftTeam: leftTeam,
      rightTeam: rightTeam,
      leftPts: leftPts,
      rightPts: rightPts
    };

    html += `
      <div class="match-card ${cls}" style="cursor:pointer;" data-no-ptr="1">
        <div class="mc-left">
          <div class="mc-name"><span class="nm">${esc(leftTeam)}</span></div>
        </div>

        <div class="mc-mid">
          <div class="mc-date-pill" style="width:100%; text-align:center; font-weight:950;">${esc(label)}</div>
          <div class="mc-score mc-score-stroke">
            <span class="${leftCls}">${esc(fmtPts(leftPts))}</span>
            <span style="opacity:.5;">–</span>
            <span class="${rightCls}">${esc(fmtPts(rightPts))}</span>
          </div>
        </div>

        <div class="mc-right">
          <div class="mc-name"><span class="nm">${esc(rightTeam)}</span></div>
        </div>
      </div>
    `;
  }

  html += "</div>";
  root.innerHTML = html;

  root.querySelectorAll(".match-card").forEach(card=>{
    card.addEventListener("click", ()=>{
      const key = card.getAttribute("data-matchup-key");
      // derive match object by winner/loser fallback above
      // easiest: locate by closest matching inner text via data index isn't needed
    });
  });

  // Delegate click handler to open modal
  root.querySelectorAll(".match-card").forEach((card, idx)=>{
    card.addEventListener("click", ()=>{
      const u = upsets[idx];
      const m = (_lastMatchups || []).find(x=>String(x.matchupKey||"") === String((u||{}).matchupKey||"")) || {
        matchupKey: (u||{}).matchupKey,
        dateKey: (u||{}).dateKey,
        dateShort: (u||{}).dateKey ? fmtDateShort(String((u||{}).dateKey)) : "",
        leftTeam: String((u||{}).winner||""),
        rightTeam: String((u||{}).loser||""),
        leftPts: Number((u||{}).winPts||0),
        rightPts: Number((u||{}).losePts||0)
      };
      openMatchDetailsModal(m);
    });
  });
}

function renderAdjustments(rows){
  const el = $("adjList");
  if (!el) return;
  if (!rows || !rows.length){
    el.innerHTML = "No adjustments yet.";
    return;
  }
  const sorted = rows.slice().sort((a,b)=> (a.dateKey||"").localeCompare(b.dateKey||"") || (a.team||"").localeCompare(b.team||""));
  let html = "<div style='display:grid; gap:8px;'>";
  for (const r of sorted){
    const dk = r.dateKey || "";
    const dateKey = parseDateKey(r.dateKey || r.dateDisp || "");
    const dateLabel = dateKey ? fmtDateShort(dateKey) : "";
    const line =
      esc(dateLabel) + " • " +
      esc((r.team||"").trim()) + " vs " + esc((r.opp||"").trim()) +
      " • " + ((Number(r.delta||0) >= 0) ? "+" : "") + esc(fmtPts(r.delta));
    html += "<div style='border:1px solid #eef2f7; border-radius:14px; padding:10px; background:#fff;'>" +
              "<div style='display:flex; justify-content:space-between; gap:10px; align-items:flex-start;'>" +
                "<div style='font-weight:950;'>" + line + "</div>" +
                "<div style='display:flex; gap:8px; flex-shrink:0;'>" +
                  "<button data-edit='"+esc(r.id)+"' style='border:1px solid #e6edf5; background:#fff; border-radius:12px; padding:7px 10px; font-weight:950;'>Edit</button>" +
                  "<button data-del='"+esc(r.id)+"' style='border:1px solid rgba(185,28,28,.25); background:rgba(185,28,28,.07); color:#7f1d1d; border-radius:12px; padding:7px 10px; font-weight:950;'>Delete</button>" +
                "</div>" +
              "</div>" +
            "</div>";
  }
  html += "</div>";
  el.innerHTML = html;

  el.querySelectorAll("button[data-edit]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-edit");
      const r = rows.find(x=>String(x.id)===String(id));
      if (!r) return;
      $("adjDate").value = (parseDateKey(r.dateKey || r.dateDisp || "") || "");
      $("adjTeam").value = r.team || "";
      $("adjOpp").value = r.opp || "";
      $("adjDelta").value = String(r.delta ?? "");
      $("adjSave").setAttribute("data-id", String(r.id||""));
      $("adjMsg").textContent = "Editing adjustment…";
    });
  });

  el.querySelectorAll("button[data-del]").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const id = btn.getAttribute("data-del");
      if (!id) return;
      $("adjMsg").textContent = "Deleting…";
      try{
        const res = await runGs("faDeleteStandingsAdjustment_v1", { id });
        if (res && res.ok){
          $("adjMsg").textContent = "Deleted.";
          await reloadAllFromServer();
        } else {
          $("adjMsg").textContent = (res && res.message) ? res.message : "Delete failed.";
        }
      }catch(e){
        $("adjMsg").textContent = e && e.message ? e.message : String(e);
      }
    });
  });
}

function clearAdjForm(){
  $("adjDate").value = "";
  $("adjTeam").value = "";
  $("adjOpp").value = "";
  $("adjDelta").value = "";
  $("adjSave").removeAttribute("data-id");
  $("adjMsg").textContent = "";
}

function wireAdjustmentForm(){
  const saveBtn = $("adjSave");
  if (!saveBtn) return;

  saveBtn.addEventListener("click", async ()=>{
    const id = saveBtn.getAttribute("data-id") || "";
    const dateKey = String($("adjDate").value||"").trim();
    const dateDisp = dateKey ? fmtDateShort(dateKey) : ""; // for UI only
    const team = String($("adjTeam").value||"").trim();
    const opp  = String($("adjOpp").value||"").trim();
    const deltaStr = String($("adjDelta").value||"").trim();
    const note = "";

    const delta = Number(deltaStr);
    if (!dateKey || !team || !opp || !isFinite(delta)){
      $("adjMsg").textContent = "Please fill Date, Team, Opponent, and a numeric Delta.";
      return;
    }

    $("adjMsg").textContent = "Saving…";
    try{
      const res = await runGs("faUpsertStandingsAdjustment_v1", { id, dateKey, team, opp, delta, note });
      if (res && res.ok){
        $("adjMsg").textContent = "Saved.";
        clearAdjForm();
        await reloadAllFromServer();
      } else {
        $("adjMsg").textContent = (res && res.message) ? res.message : "Save failed.";
      }
    }catch(e){
      $("adjMsg").textContent = e && e.message ? e.message : String(e);
    }
  });
}

async function reloadAllFromServer(){
  const packRaw = await runGs("faGetStandingsPack_v1", { upsetLimit: 15 });
  let pack = packRaw;
  try{ if (typeof pack === "string") pack = JSON.parse(pack); }catch(_){}
  if (!pack || pack.ok === false) throw new Error((pack && pack.message) ? pack.message : "Standings pack load failed.");

  // League-wide match meta (home/neutral)
  try{
    if (pack.meta) _setMatchMetaMapFromServer_(pack.meta);
    _matchMetaLoaded = true;
  }catch(e){
    console.warn("MatchMeta parse failed:", e);
    _matchMetaLoaded = true;
  }

  const standings = pack.standings || [];
  const matchdays = (pack.matchdays || []).map(m=>{
    const dk = String(m.dateKey||"").trim();
    return Object.assign({}, m, { dateShort: dk ? fmtDateShort(dk) : "" });
  });

  _lastMatchups = matchdays;

  renderStandings(standings, matchdays.length);
  fillTeamDropdowns(standings);
  initSimulator(standings);

  renderMatchups(matchdays);
  renderUpsets(pack.upsets || []);
  renderAdjustments(pack.adjustments || []);
}

async function load(){
  try{
    const adjWrap = $("adjWrap");
    if (adjWrap) adjWrap.style.display = "";

    await reloadAllFromServer();
    wireAdjustmentForm();

  }catch(err){
    const metaEl = $("meta");
    if (metaEl) metaEl.textContent = "Load failed: " + (err && err.message ? err.message : err);
    console.error(err);
  }
}
load();
</script>


</body>
</html>


